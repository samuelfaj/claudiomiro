const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const state = require('../../../../shared/config/state');
const logger = require('../../../../shared/utils/logger');
const { smartCommit } = require('../../../../shared/services/git-commit');

/**
 * Step 8: Final Commit and Pull Request
 *
 * Finalizes the entire workflow by:
 * 1. Generating a summary from all task CODE_REVIEW.md files
 * 2. Creating a final commit with all changes (using Ollama for message, shell for git)
 * 3. Creating a pull request (if shouldPush is true, falls back to Claude for PR)
 * 4. Ensuring no traces of automation are visible in commits or PRs
 *
 * Token optimization: Uses shell + Ollama for commits, only falls back to Claude on errors or for PR creation.
 *
 * Multi-repo support:
 * - Single-repo / Monorepo: Uses smartCommit with createPR: true (existing behavior)
 * - Separate git mode: Creates independent PRs in each repo with cross-references
 */

/**
 * Creates a pull request using gh CLI
 * @param {string} cwd - Working directory for the git operation
 * @param {string} title - PR title
 * @param {string} body - PR body/description
 * @returns {string|null} PR URL or null on failure
 */
const createPullRequest = (cwd, title, body) => {
    try {
        // Use heredoc pattern for safe shell escaping
        const command = `gh pr create --title "$(cat <<'TITLE_EOF'
${title}
TITLE_EOF
)" --body "$(cat <<'BODY_EOF'
${body}
BODY_EOF
)"`;

        const result = execSync(command, {
            cwd,
            encoding: 'utf-8',
            stdio: 'pipe',
            timeout: 60000,
        });

        // Extract PR URL from output (last non-empty line)
        const lines = result.trim().split('\n');
        const prUrl = lines[lines.length - 1].trim();
        return prUrl;
    } catch (error) {
        logger.warning(`Failed to create PR in ${cwd}: ${error.message}`);
        return null;
    }
};

/**
 * Updates a PR body with the given content
 * @param {string} cwd - Working directory for the git operation
 * @param {string} body - New PR body
 * @returns {boolean} True if update succeeded
 */
const updatePrBody = (cwd, body) => {
    try {
        const updateCommand = `gh pr edit --body "$(cat <<'BODY_EOF'
${body}
BODY_EOF
)"`;

        execSync(updateCommand, {
            cwd,
            encoding: 'utf-8',
            stdio: 'pipe',
            timeout: 30000,
        });
        return true;
    } catch (error) {
        logger.warning(`Failed to update PR in ${cwd}: ${error.message}`);
        return false;
    }
};

/**
 * Creates pull requests for multi-repo setup with cross-references
 * Creates both PRs first, then updates with cross-references to avoid race conditions
 * @param {string} featureName - Name of the feature for PR titles
 * @returns {Promise<void>}
 */
const createMultiRepoPullRequests = async (featureName) => {
    const backendCwd = state.getRepository('backend');
    const frontendCwd = state.getRepository('frontend');

    const safeName = featureName || 'Multi-repo changes';

    // Create both PRs first without cross-references
    logger.info('Creating backend PR...');
    const backendPrUrl = createPullRequest(
        backendCwd,
        `feat: ${safeName} (Backend)`,
        `## Summary
Backend changes for: ${safeName}

---
ü§ñ Generated by Claudiomiro`,
    );

    if (backendPrUrl) {
        logger.info(`Created backend PR: ${backendPrUrl}`);
    }

    logger.info('Creating frontend PR...');
    const frontendPrUrl = createPullRequest(
        frontendCwd,
        `feat: ${safeName} (Frontend)`,
        `## Summary
Frontend changes for: ${safeName}

---
ü§ñ Generated by Claudiomiro`,
    );

    if (frontendPrUrl) {
        logger.info(`Created frontend PR: ${frontendPrUrl}`);
    }

    // Now update both PRs with cross-references
    if (backendPrUrl && frontendPrUrl) {
        // Update backend PR with frontend link
        logger.info('Updating PRs with cross-references...');
        updatePrBody(backendCwd, `## Summary
Backend changes for: ${safeName}

## Related PRs
Frontend PR: ${frontendPrUrl}

---
ü§ñ Generated by Claudiomiro`);

        // Update frontend PR with backend link
        updatePrBody(frontendCwd, `## Summary
Frontend changes for: ${safeName}

## Related PRs
Backend PR: ${backendPrUrl}

---
ü§ñ Generated by Claudiomiro`);

        logger.info('PRs updated with cross-references');
    } else if (backendPrUrl && !frontendPrUrl) {
        // Frontend PR failed - update backend to reflect this
        logger.warning('Frontend PR creation failed, updating backend PR...');
        updatePrBody(backendCwd, `## Summary
Backend changes for: ${safeName}

## Related PRs
Frontend PR: ‚ö†Ô∏è Failed to create

---
ü§ñ Generated by Claudiomiro`);
    } else if (!backendPrUrl && frontendPrUrl) {
        // Backend PR failed - update frontend to reflect this
        logger.warning('Backend PR creation failed, updating frontend PR...');
        updatePrBody(frontendCwd, `## Summary
Frontend changes for: ${safeName}

## Related PRs
Backend PR: ‚ö†Ô∏è Failed to create

---
ü§ñ Generated by Claudiomiro`);
    }
};

const step8 = async (tasks, shouldPush = true) => {
    try {
        // Check if we're in multi-repo separate git mode
        const isMultiRepoSeparate = state.isMultiRepo() && state.getGitMode() === 'separate';

        if (isMultiRepoSeparate && shouldPush) {
            // Multi-repo separate mode: commit in each repo and create linked PRs
            logger.info('üì¶ Multi-repo mode detected: creating commits and PRs for each repository');

            // Get and validate repository paths
            const backendCwd = state.getRepository('backend');
            const frontendCwd = state.getRepository('frontend');

            if (!backendCwd || !frontendCwd) {
                throw new Error('Multi-repo mode requires both backend and frontend repositories configured');
            }

            if (backendCwd === frontendCwd) {
                throw new Error('Multi-repo separate mode requires distinct backend and frontend paths');
            }

            // Commit in backend repo
            await smartCommit({
                taskName: null,
                shouldPush: true,
                createPR: false, // We'll create PRs separately with cross-references
                cwd: backendCwd,
            });
            logger.info('üì¶ Backend commit complete');

            // Commit in frontend repo
            await smartCommit({
                taskName: null,
                shouldPush: true,
                createPR: false,
                cwd: frontendCwd,
            });
            logger.info('üì¶ Frontend commit complete');

            // Extract feature name from INITIAL_PROMPT.md for meaningful PR titles
            const initialPromptPath = path.join(state.claudiomiroFolder, 'INITIAL_PROMPT.md');
            let featureName = 'Multi-repo changes';
            if (fs.existsSync(initialPromptPath)) {
                const content = fs.readFileSync(initialPromptPath, 'utf-8').trim();
                // Take first line or first 80 chars as feature name
                const firstLine = content.split('\n')[0].trim();
                featureName = firstLine.substring(0, 80) || featureName;
            }

            // Create PRs with cross-references
            await createMultiRepoPullRequests(featureName);
        } else {
            // Single-repo or monorepo: use existing behavior
            const commitResult = await smartCommit({
                taskName: null, // Final commit, no specific task
                shouldPush,
                createPR: shouldPush, // Create PR if pushing
            });

            if (commitResult.method === 'shell') {
                logger.info('üì¶ Final commit via shell (saved Claude tokens)');
            } else if (commitResult.method === 'claude') {
                logger.info('üì¶ Final commit/PR via Claude');
            }
        }

        fs.writeFileSync(path.join(state.claudiomiroFolder, 'done.txt'), '1');
    } catch (error) {
        // Log but don't block execution
        logger.warning('‚ö†Ô∏è  Commit/PR failed in step8, continuing anyway:', error.message);
    }

    logger.info(`‚úÖ Claudiomiro has been successfully executed. Check out: ${state.folder}`);
    process.exit(0);
};

module.exports = { step8 };
