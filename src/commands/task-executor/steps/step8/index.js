const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');
const state = require('../../../../shared/config/state');
const logger = require('../../../../shared/utils/logger');
const { smartCommit } = require('../../../../shared/services/git-commit');

/**
 * Step 8: Final Commit and Pull Request
 *
 * Finalizes the entire workflow by:
 * 1. Generating a summary from all task CODE_REVIEW.md files
 * 2. Creating a final commit with all changes (using Ollama for message, shell for git)
 * 3. Creating a pull request (if shouldPush is true, falls back to Claude for PR)
 * 4. Ensuring no traces of automation are visible in commits or PRs
 *
 * Token optimization: Uses shell + Ollama for commits, only falls back to Claude on errors or for PR creation.
 *
 * Multi-repo support:
 * - Single-repo / Monorepo: Uses smartCommit with createPR: true (existing behavior)
 * - Separate git mode: Creates independent PRs in each repo with cross-references
 */

/**
 * Creates a pull request using gh CLI
 * @param {string} cwd - Working directory for the git operation
 * @param {string} title - PR title
 * @param {string} body - PR body/description
 * @returns {string|null} PR URL or null on failure
 */
const createPullRequest = (cwd, title, body) => {
    try {
        // Use heredoc pattern for safe shell escaping
        const command = `gh pr create --title "$(cat <<'TITLE_EOF'
${title}
TITLE_EOF
)" --body "$(cat <<'BODY_EOF'
${body}
BODY_EOF
)"`;

        const result = execSync(command, {
            cwd,
            encoding: 'utf-8',
            stdio: 'pipe',
            timeout: 60000,
        });

        // Extract PR URL from output (last non-empty line)
        const lines = result.trim().split('\n');
        const prUrl = lines[lines.length - 1].trim();
        return prUrl;
    } catch (error) {
        logger.warning(`Failed to create PR in ${cwd}: ${error.message}`);
        return null;
    }
};

/**
 * Creates pull requests for multi-repo setup with cross-references
 * @param {string} featureName - Name of the feature for PR titles
 * @returns {Promise<void>}
 */
const createMultiRepoPullRequests = async (featureName) => {
    const backendCwd = state.getRepository('backend');
    const frontendCwd = state.getRepository('frontend');

    const safeName = featureName || 'Multi-repo changes';

    // Create backend PR first
    logger.info('Creating backend PR...');
    const backendPrUrl = createPullRequest(
        backendCwd,
        `feat: ${safeName} (Backend)`,
        `## Summary
Backend changes for: ${safeName}

## Related PRs
Frontend PR: _pending creation_

---
ü§ñ Generated by Claudiomiro`,
    );

    if (backendPrUrl) {
        logger.info(`Created backend PR: ${backendPrUrl}`);
    }

    // Create frontend PR with backend reference
    logger.info('Creating frontend PR...');
    const frontendPrUrl = createPullRequest(
        frontendCwd,
        `feat: ${safeName} (Frontend)`,
        `## Summary
Frontend changes for: ${safeName}

## Related PRs
Backend PR: ${backendPrUrl || '_not available_'}

---
ü§ñ Generated by Claudiomiro`,
    );

    if (frontendPrUrl) {
        logger.info(`Created frontend PR: ${frontendPrUrl}`);
    }

    // Update backend PR with frontend reference
    if (backendPrUrl && frontendPrUrl) {
        try {
            logger.info('Updating backend PR with frontend link...');
            const updateCommand = `gh pr edit --body "$(cat <<'BODY_EOF'
## Summary
Backend changes for: ${safeName}

## Related PRs
Frontend PR: ${frontendPrUrl}

---
ü§ñ Generated by Claudiomiro
BODY_EOF
)"`;

            execSync(updateCommand, {
                cwd: backendCwd,
                encoding: 'utf-8',
                stdio: 'pipe',
                timeout: 30000,
            });
            logger.info('Updated backend PR with frontend link');
        } catch (error) {
            logger.warning(`Failed to update backend PR: ${error.message}`);
        }
    }
};

const step8 = async (tasks, shouldPush = true) => {
    try {
        // Check if we're in multi-repo separate git mode
        const isMultiRepoSeparate = state.isMultiRepo() && state.getGitMode() === 'separate';

        if (isMultiRepoSeparate && shouldPush) {
            // Multi-repo separate mode: commit in each repo and create linked PRs
            logger.info('üì¶ Multi-repo mode detected: creating commits and PRs for each repository');

            // Commit in backend repo
            const backendCwd = state.getRepository('backend');
            await smartCommit({
                taskName: null,
                shouldPush: true,
                createPR: false, // We'll create PRs separately with cross-references
                cwd: backendCwd,
            });
            logger.info('üì¶ Backend commit complete');

            // Commit in frontend repo
            const frontendCwd = state.getRepository('frontend');
            await smartCommit({
                taskName: null,
                shouldPush: true,
                createPR: false,
                cwd: frontendCwd,
            });
            logger.info('üì¶ Frontend commit complete');

            // Create PRs with cross-references
            await createMultiRepoPullRequests('Multi-repo feature');
        } else {
            // Single-repo or monorepo: use existing behavior
            const commitResult = await smartCommit({
                taskName: null, // Final commit, no specific task
                shouldPush,
                createPR: shouldPush, // Create PR if pushing
            });

            if (commitResult.method === 'shell') {
                logger.info('üì¶ Final commit via shell (saved Claude tokens)');
            } else if (commitResult.method === 'claude') {
                logger.info('üì¶ Final commit/PR via Claude');
            }
        }

        fs.writeFileSync(path.join(state.claudiomiroFolder, 'done.txt'), '1');
    } catch (error) {
        // Log but don't block execution
        logger.warning('‚ö†Ô∏è  Commit/PR failed in step8, continuing anyway:', error.message);
    }

    logger.info(`‚úÖ Claudiomiro has been successfully executed. Check out: ${state.folder}`);
    process.exit(0);
};

module.exports = { step8 };
