const fs = require('fs');
const path = require('path');
const state = require('../../../../shared/config/state');
const logger = require('../../../../shared/utils/logger');

/**
 * State file names for the refinement loop
 */
const STATE_FILES = {
    TODO: 'PROMPT_REFINEMENT_TODO.md',
    OVERVIEW: 'PROMPT_REFINEMENT_OVERVIEW.md',
    PASSED: 'PROMPT_REFINEMENT_PASSED.md',
};

/**
 * Get paths to all state files
 * @returns {Object} Object with todoPath, overviewPath, passedPath
 */
const getStatePaths = () => {
    const folder = state.claudiomiroFolder;
    return {
        todoPath: path.join(folder, STATE_FILES.TODO),
        overviewPath: path.join(folder, STATE_FILES.OVERVIEW),
        passedPath: path.join(folder, STATE_FILES.PASSED),
    };
};

/**
 * Count pending items in PROMPT_REFINEMENT_TODO.md
 * Counts lines that match `- [ ]` pattern (unchecked items)
 *
 * @param {string} todoPath - Path to PROMPT_REFINEMENT_TODO.md file
 * @returns {number} Count of pending items
 */
const countPendingItems = (todoPath) => {
    if (!fs.existsSync(todoPath)) {
        return 0;
    }

    try {
        const content = fs.readFileSync(todoPath, 'utf-8');
        const matches = content.match(/- \[ \]/g);
        return matches ? matches.length : 0;
    } catch (error) {
        logger.warning(`Could not read ${STATE_FILES.TODO}: ${error.message}`);
        return 0;
    }
};

/**
 * Count completed items in PROMPT_REFINEMENT_TODO.md
 * Counts lines that match `- [x]` pattern (checked items, case-insensitive)
 *
 * @param {string} todoPath - Path to PROMPT_REFINEMENT_TODO.md file
 * @returns {number} Count of completed items
 */
const countCompletedItems = (todoPath) => {
    if (!fs.existsSync(todoPath)) {
        return 0;
    }

    try {
        const content = fs.readFileSync(todoPath, 'utf-8');
        const matches = content.match(/- \[x\]/gi);
        return matches ? matches.length : 0;
    } catch (error) {
        logger.warning(`Could not read ${STATE_FILES.TODO}: ${error.message}`);
        return 0;
    }
};

/**
 * Check if refinement loop is in verification phase
 * @returns {boolean} True if OVERVIEW file exists (verification phase)
 */
const isVerificationPhase = () => {
    const { overviewPath } = getStatePaths();
    return fs.existsSync(overviewPath);
};

/**
 * Check if verification has passed (loop complete)
 * @returns {boolean} True if PASSED file exists
 */
const isVerificationPassed = () => {
    const { passedPath } = getStatePaths();
    return fs.existsSync(passedPath);
};

/**
 * Delete OVERVIEW file to return to refinement phase
 * Used when verification finds new issues
 */
const deleteOverview = () => {
    const { overviewPath } = getStatePaths();
    if (fs.existsSync(overviewPath)) {
        try {
            fs.unlinkSync(overviewPath);
            logger.debug('Deleted OVERVIEW file, returning to refinement phase');
        } catch (error) {
            logger.warning(`Could not delete ${STATE_FILES.OVERVIEW}: ${error.message}`);
        }
    }
};

/**
 * Create the PASSED file to signal verification success
 * @param {number} completedCount - Number of completed items
 * @param {number} iterations - Number of iterations taken
 */
const createPassedFile = (completedCount, iterations) => {
    const { passedPath } = getStatePaths();
    const passedContent = `# AI_PROMPT.md Refinement Passed

**Verification Date**: ${new Date().toISOString()}

## Result

All refinement checks passed. The AI_PROMPT.md is ready for task decomposition.

## Summary

- Total refinement items processed: ${completedCount}
- Completed in ${iterations} iteration(s)

## Verified Aspects

- Context completeness: All necessary codebase context collected
- Clarity: No ambiguities in the prompt
- Coverage: All user requirements represented

*This file was generated by the refinement loop verification phase.*
`;
    fs.writeFileSync(passedPath, passedContent, 'utf-8');
    logger.debug('Created PASSED file, verification complete');
};

/**
 * Clear all state files (for fresh start)
 */
const clearStateFiles = () => {
    const paths = getStatePaths();
    for (const [name, filePath] of Object.entries(paths)) {
        if (fs.existsSync(filePath)) {
            try {
                fs.unlinkSync(filePath);
                logger.debug(`Cleared state file: ${name}`);
            } catch (error) {
                logger.warning(`Could not delete ${name}: ${error.message}`);
            }
        }
    }
};

module.exports = {
    STATE_FILES,
    getStatePaths,
    countPendingItems,
    countCompletedItems,
    isVerificationPhase,
    isVerificationPassed,
    deleteOverview,
    createPassedFile,
    clearStateFiles,
};
