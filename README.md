# Claudiomiro

![Claudiomiro](https://github.com/samuelfaj/claudiomiro/blob/main/claudiomiro.png?raw=true)


**Send your prompt ‚Äî get a fully planned, executed, reviewed, tested and committed task.**

Turn days of complex development into a fully automated process ‚Äî without sacrificing production-grade code quality.

**Works With:**
- ‚úÖ Claude Code
- ‚úÖ ChatGPT Codex
- ‚úÖ DeepSeek [(How to)](./DEEPSEEK.md)

**Examples:**
- üí¨ [‚ÄúImplement Express.js with some basic routes and JWT.‚Äù](https://github.com/samuelfaj/claudiomiro-express-example) - Claude
- üí¨ [‚ÄúCreate the classic Snake game entirely in JavaScript to run in the browser.‚Äù](https://github.com/samuelfaj/claudiomiro-snake-game-example) - Codex

------

## The Problem with Agents

When using Claude Code / Cursor / Codex for complex tasks, you've probably noticed it **stops before completing the job**. The result? You find yourself typing "continue", testing, reviewing, over and over again, managing all the workflow manually.

------

## What is Claudiomiro?

**Claudiomiro** is a Node.js CLI that wraps Claude AI or OpenAI Codex in a structured, **autonomous workflow** with **parallel task execution**. Unlike simple code generators, Claudiomiro:

- ‚úÖ Thinks through complex problems
- ‚úÖ Analyzes your entire codebase
- ‚úÖ Identifies patterns and best practices
- ‚úÖ **Maximizes parallelism** - executes independent tasks simultaneously
- ‚úÖ Implements comprehensive solutions
- ‚úÖ **Runs autonomously until completion** (up to 20 cycles per task)

-----

### The Magic: Autonomous Looping + Parallel Execution

Claudiomiro doesn't just run once. It **loops autonomously** until the entire task is complete, and **executes independent tasks in parallel** to maximize speed:

```
Cycle 1: [Step 0] Decomposing complex task into 5 parallelizable sub-tasks
Cycle 2: [Step 1] Analyzing dependencies and creating execution plan
         ‚Üí EXECUTION_PLAN.md created (3 layers, max 4 parallel tasks)

Parallel Execution Started (DAG Executor):
  üöÄ Running 4 tasks in parallel: TASK2, TASK3, TASK4, TASK5
  ‚ñ∂Ô∏è  TASK2: Research ‚Üí Implement ‚Üí Code Review ‚Üí Tests... ‚úÖ
  ‚ñ∂Ô∏è  TASK3: Research ‚Üí Implement ‚Üí Code Review ‚Üí Tests... ‚úÖ
  ‚ñ∂Ô∏è  TASK4: Research ‚Üí Implement ‚Üí Code Review ‚Üí Tests... ‚úÖ
  ‚ñ∂Ô∏è  TASK5: Research ‚Üí Implement ‚Üí Code Review ‚Üí Tests... ‚úÖ

  üöÄ Running 1 task in parallel: TASK6 (depends on TASK2-5)
  ‚ñ∂Ô∏è  TASK6: Integration tests... ‚úÖ

Cycle 3: [Step 5] Creating commit and pushing

‚úì Task completed in 3 autonomous cycles (4 tasks ran in parallel)
```

No manual intervention. No "continue" prompts. Just complete, production-ready code ‚Äî **now faster with parallel execution**.

### Safety Mechanisms

- **Maximum 20 cycles per task** - Prevents runaway execution within each task (customize with `--limit=N` or disable with `--no-limit`)
- **Progress validation** - Ensures forward progress each cycle
- **Error detection** - Stops if same error repeats
- **Manual override** - Use `--push=false` to review before final commit

## Key Features

- üîÑ **Truly Autonomous**: Loops until task is 100% complete
- ‚ö° **Parallel Execution**: Runs independent tasks simultaneously (2 per CPU core, max 5)
- üß© **Intelligent Decomposition**: Breaks complex tasks into granular, independent sub-tasks optimized for parallelism
- üìä **Smart Dependency Analysis**: Creates execution plan with layers and critical path
- üéØ **Dual Planning Modes**: Choose between auto (speed) or hard (maximum criticality + deep reasoning)
- üß† **Deep Analysis**: Understands your codebase patterns and architecture
- üë®‚Äçüíª **Automated Code Review**: Senior-level review validates quality before testing
- üß™ **Quality Enforced**: Never skips tests, always validates
- üìä **Full Transparency**: Live logs show every decision and action
- üéØ **Production Ready**: Code is tested, reviewed, documented, and ready to merge
- ‚ö° **Massive Time Savings**: 95-98% reduction in development time

## Prerequisites for Optimal Performance

For best results, your project should have:

**Minimum:**
- Basic linting (ESLint, Pylint, etc.)
- Some unit tests for core functionality

**Optimal:**
- Comprehensive linting with strict rules
- High test coverage (>80%)
- Integration tests for critical paths
- MCPs configured (gives Claude/Codex superpowers)

**Why?** Linting and tests create a **feedback loop** that enables Claudiomiro to validate its work and iterate autonomously until everything is perfect.

## Installation

```bash
npm install -g claudiomiro
```

## Quick Start

```bash
# Run with a complex task
claudiomiro --prompt="Your complex task description here"

# Or run interactively
claudiomiro
```

That's it! Claudiomiro will autonomously handle the rest.

### Selecting the Executor

- Claude CLI remains the default executor; pass `--claude` to force it explicitly.
- To run the workflow with OpenAI Codex, install the Codex CLI and add `--codex` to your command.
- Both executors share the same prompts and parallel workflow. Pick the one that best matches your environment or credential setup.

## Usage Examples

### Basic Usage
```bash
# Run in current directory with a task
claudiomiro --prompt="Add user authentication with JWT"

# Run in specific directory
claudiomiro /path/to/project --prompt="Refactor payment processing"

# Interactive mode (prompts you for task description)
claudiomiro
```

### Advanced Options
```bash
# Review changes before pushing (recommended for first use)
claudiomiro --prompt="Implement dark mode" --push=false

# Work on current branch (no new branch created)
claudiomiro --prompt="Fix login bug" --same-branch

# Start fresh (removes all generated files)
claudiomiro --fresh

# Change cycle limit per task (default: 20)
claudiomiro --prompt="Complex refactoring" --limit=50

# Remove cycle limit per task (use with caution)
claudiomiro --prompt="Very complex task" --no-limit

# Control parallel execution (default: 2 per core, max 5)
claudiomiro --prompt="Build microservices" --maxConcurrent=10

# Task planning mode (auto or hard)
claudiomiro --prompt="Build REST API" --mode=hard  # Maximum criticality + reasoning
claudiomiro --prompt="Add feature" --mode=auto     # Default: parallelism-focused

# Choose AI executor (default: Claude)
claudiomiro --prompt="Migrate to microfrontends" --codex
claudiomiro --prompt="Run security audit" --claude

# Run only specific steps
claudiomiro --steps=2,3,4  # Skip planning, only implement
claudiomiro --step=0       # Only create task decomposition

# Combine options
claudiomiro /path/to/project --prompt="Add GraphQL API" --push=false --maxConcurrent=8 --mode=hard
```

### Example Prompts

**Eliminating Duplication:**
```bash
claudiomiro --prompt="These files are nearly identical:
/src/modules/bills-to-pay-form
/src/modules/bills-to-receive-form
Unify them into shared components to eliminate duplication."
```

**Feature Implementation:**
```bash
claudiomiro --prompt="Create a user onboarding system with:
- Multi-step form (profile, company, preferences)
- Email verification
- Progress saving
- Mobile responsive
- Full test coverage"
```

**Large Refactoring:**
```bash
claudiomiro --prompt="Migrate from REST to GraphQL:
- Convert all API endpoints
- Update all frontend calls
- Maintain backward compatibility during transition
- Add comprehensive tests"
```

**Bug Investigation:**
```bash
claudiomiro --prompt="Users report intermittent data corruption.
Investigate root cause in /services/FinancialService.js
and fix with proper tests to prevent regression."
```


## Generated Files

Claudiomiro creates a `.claudiomiro/` folder to organize tasks and track progress:

```
.claudiomiro/
‚îú‚îÄ‚îÄ EXECUTION_PLAN.md        # Parallel execution strategy with dependency graph
‚îú‚îÄ‚îÄ TASK1/
‚îÇ   ‚îú‚îÄ‚îÄ TASK.md              # Self-contained task with dependencies (Depends on: NONE)
‚îÇ   ‚îú‚îÄ‚îÄ PROMPT.md            # Enhanced description with parallelization notes
‚îÇ   ‚îú‚îÄ‚îÄ TODO.md              # Detailed breakdown (`Fully implemented: YES/NO`)
‚îÇ   ‚îî‚îÄ‚îÄ CODE_REVIEW.md       # Automated code review report
‚îú‚îÄ‚îÄ TASK2/
‚îÇ   ‚îú‚îÄ‚îÄ TASK.md              # Dependencies: TASK1 | Parallel with: TASK3, TASK4
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ TASK3/
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îî‚îÄ‚îÄ log.txt                  # Complete execution log with timestamps
```

**Key Files:**
- **EXECUTION_PLAN.md**: Visual map showing execution layers, dependency graph, critical path, and parallelism ratio
- **TASK.md**: Each task is fully self-contained with explicit dependencies (or NONE for parallel tasks)
- **PROMPT.md**: Includes parallelization notes (layer, parallel siblings, complexity)
- **TODO.md**: Tracks implementation status; must begin with `Fully implemented: YES/NO`
- **CODE_REVIEW.md**: Approval status for the task; Claudiomiro waits for an approved review before considering a task done

**Tip:** Review `EXECUTION_PLAN.md` early to validate the parallel execution strategy. Use `--fresh` to start over.

## Planning Modes

Claudiomiro offers two planning modes to balance speed vs. criticality:

### **Auto Mode (Default)** ‚Äî Optimized for Speed
```bash
claudiomiro --prompt="Add new feature" --mode=auto
```

**Best for:**
- Standard features and refactorings
- Projects with good existing test coverage
- Quick iterations and prototyping

**Characteristics:**
- ‚ö° Maximum parallelization focus
- üìã Standard task decomposition
- ‚úÖ Essential acceptance criteria (3-5 items)
- üéØ Streamlined execution

### **Hard Mode** ‚Äî Maximum Criticality
```bash
claudiomiro --prompt="Build payment system" --mode=hard
```

**Best for:**
- Critical systems (payments, auth, security)
- Complex business logic
- Projects requiring extensive documentation
- Mission-critical features

**Characteristics:**
- üß† **Deep reasoning traces** for every decision
- üìù **Explicit assumptions** documented per task
- üî¨ **Research summaries** with edge cases
- ‚úÖ **Rigorous acceptance criteria** (5-10 items per task)
- üîÑ **Self-verification logic** for each task
- üö® **Escalation protocols** for blockers
- üìä **Dependency reasoning** with risk analysis
- ‚ö° **Maintains full parallelization** from auto mode

**Example Hard Mode Output:**

Each task includes:
```markdown
## Assumptions
- Database uses PostgreSQL 14+
- Payment provider is Stripe API v2023-10-16
- User sessions last 24 hours

## Reasoning Trace
- Why this approach? Separates payment intent from confirmation for better error handling
- What alternatives were rejected? Direct charge API (no retry mechanism)
- What risks exist? Race conditions on concurrent payments ‚Üí mitigated with idempotency keys

## Acceptance Criteria (Rigorous)
- [ ] Payment intent created with idempotency key
- [ ] Webhook signature verified using Stripe SDK
- [ ] Failed payments logged with full context
- [ ] Retry mechanism implemented with exponential backoff
- [ ] All error cases have specific handling
- [ ] Database transaction rollback on payment failure
- [ ] Unit tests cover 95%+ of payment logic
- [ ] Integration tests mock Stripe API calls
- [ ] Load tested with 100 concurrent payments
- [ ] Security audit passes (no secrets in logs)
```

**When to use Hard Mode:**
- üí∞ Financial/payment systems
- üîê Authentication/authorization
- üìä Critical business logic
- üè• Healthcare/compliance-heavy domains
- ‚ö†Ô∏è Any feature where errors = major issues

## Requirements

- **Node.js** (v14+)
- **Git repository** (initialized with at least one commit)
- **Claude CLI** installed and configured ([Setup Guide](https://docs.anthropic.com/claude/docs)) or 
- **Codex CLI** installed and authenticated (only if you plan to use `--codex`, see [Codex exec docs](https://github.com/openai/codex/blob/main/docs/exec.md))

## What Makes This Different?

Traditional AI assistants:
- ‚ùå Stop after one response
- ‚ùå Handle one monolithic task
- ‚ùå No code quality validation
- ‚ùå You manually run tests
- ‚ùå You manually fix failures
- ‚ùå You create commits/PRs
- ‚ùå No structured approach

**Claudiomiro:**
- ‚úÖ Runs autonomously until complete (up to 20 cycles per task)
- ‚úÖ Decomposes complex tasks with parallelism optimization
- ‚úÖ Executes independent tasks simultaneously (DAG executor)
- ‚úÖ Smart dependency analysis and execution planning
- ‚úÖ Built-in senior-level code review
- ‚úÖ Automatically runs tests
- ‚úÖ Automatically fixes test failures
- ‚úÖ Creates commits and PRs
- ‚úÖ Structured 6-step workflow with quality gates
- ‚úÖ Production-ready output ‚Äî faster with parallel execution

## Contributing

Issues and PRs welcome! Please check the [issues page](https://github.com/yourusername/claudiomiro/issues).

## License

ISC