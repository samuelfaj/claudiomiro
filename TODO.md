Generated by Claudiomiro

# TODO: Melhorias Avan√ßadas do Claudiomiro 2.0

> Este documento descreve as melhorias avan√ßadas identificadas na an√°lise comparativa com CodeMachine-CLI, combinando o melhor dos dois projetos para criar algo superior a ambos.

---

## Vis√£o Geral

| # | Melhoria | Prioridade | Esfor√ßo | Impacto |
|---|----------|------------|---------|---------|
| 1 | Three-Phase Generation | Alta | Baixo | Alto |
| 2 | Learning Fallback System | Alta | M√©dio | Alto |
| 3 | Cross-Task Learning | Alta | M√©dio | Alto |
| 4 | Context-Aware Instructions | M√©dia | Baixo | M√©dio |
| 5 | Confidence-Based Checkpoints | M√©dia | Baixo | M√©dio |
| 6 | Predictive Behavior Control | M√©dia | M√©dio | M√©dio |
| 7 | Semantic Anchors | Baixa | Alto | M√©dio |
| 8 | Symbol-Linked Briefings | Baixa | Alto | M√©dio |
| 9 | Legacy Systems Reference | Alta | M√©dio | Muito Alto |
| 10 | **Multi-Model Orchestration** | **Cr√≠tica** | **M√©dio** | **Muito Alto** |
| 11 | **Incremental Verification** | **Cr√≠tica** | **M√©dio** | **Muito Alto** |
| 12 | **Specification-First Development** | **Alta** | **Baixo** | **Muito Alto** |
| 13 | **Smart Auto-Rollback** | **Alta** | **Baixo** | **Alto** |

---

## 1. Three-Phase Generation

### O Que √â
Evolu√ß√£o do Two-Phase do CodeMachine. Adiciona uma fase de descoberta antes do planejamento.

### Fases
```
FASE 0: DESCOBERTA     ‚Üí Usa Code Index para encontrar padr√µes
FASE 1: PLANEJAMENTO   ‚Üí Estrat√©gia baseada nos padr√µes encontrados
FASE 2: IMPLEMENTA√á√ÉO  ‚Üí C√≥digo seguindo o plano
```

### Como Implementar

**Arquivo:** `src/commands/task-executor/steps/step5/prompt.md`

```markdown
## FASE 0: DESCOBERTA INTELIGENTE

Antes de planejar, analise o projeto:

1. **Busque s√≠mbolos relacionados** √† tarefa atual
   - Fun√ß√µes com nomes similares
   - Classes que implementam funcionalidade parecida
   - Tipos/interfaces relevantes

2. **Trace depend√™ncias** dos arquivos que ser√£o modificados
   - O que importa esses arquivos?
   - O que esses arquivos importam?

3. **Encontre implementa√ß√µes similares**
   - Como problemas parecidos foram resolvidos?
   - Quais padr√µes foram usados?

**OUTPUT FASE 0:** Lista de padr√µes encontrados com file:line

---

## FASE 1: PLANEJAMENTO ESTRAT√âGICO

Com base nos padr√µes da Fase 0:

1. Qual abordagem **segue os padr√µes existentes**?
2. Quais fun√ß√µes/classes podem ser **reutilizadas**?
3. Onde inserir c√≥digo para **manter consist√™ncia**?
4. Quais **edge cases** podem ocorrer?

**OUTPUT FASE 1:** Plano numerado de implementa√ß√£o

---

## FASE 2: IMPLEMENTA√á√ÉO

Execute o plano da Fase 1, reutilizando os padr√µes da Fase 0.

Se encontrar problema n√£o previsto:
1. PARE a implementa√ß√£o
2. Volte √† Fase 1 e revise o plano
3. Continue ap√≥s revis√£o
```

**Arquivo:** `src/commands/task-executor/steps/step5/index.js`

```javascript
// Adicionar no in√≠cio do prompt
const threePhaseInstructions = fs.readFileSync(
  path.join(__dirname, 'three-phase-prompt.md'),
  'utf-8'
);

// Injetar antes do TODO.md content
const enhancedPrompt = `
${threePhaseInstructions}

---

## TAREFA ATUAL

${todoContent}
`;
```

### Ganhos Estimados
- **Assertividade:** +25-35% (c√≥digo mais consistente com projeto)
- **Retrabalho:** -30% (menos refatora√ß√£o por inconsist√™ncia)

---

## 2. Learning Fallback System

### O Que √â
Sistema de fallback que aprende com erros anteriores e aplica estrat√©gias que j√° funcionaram.

### Como Implementar

**Novo arquivo:** `src/shared/services/fallback-learning/index.js`

```javascript
const fs = require('fs');
const path = require('path');
const { getLocalLLMService } = require('../local-llm');

const FAILURE_DB_PATH = '.claudiomiro/cache/failure-patterns.json';

// Tipos de erro conhecidos
const ERROR_TYPES = {
  SYNTAX_ERROR: 'syntax_error',
  TYPE_ERROR: 'type_error',
  IMPORT_ERROR: 'import_error',
  TEST_FAILURE: 'test_failure',
  BUILD_FAILURE: 'build_failure',
  TIMEOUT: 'timeout',
  INCOMPLETE: 'incomplete_implementation',
  UNKNOWN: 'unknown'
};

// Classificar erro usando Local LLM ou regex
const classifyError = async (failedOutput) => {
  const llm = getLocalLLMService();

  if (llm && llm.isAvailable()) {
    try {
      const classification = await llm.classify(failedOutput, Object.values(ERROR_TYPES));
      return classification;
    } catch (e) {
      // Fallback para regex
    }
  }

  // Fallback: regex patterns
  if (/SyntaxError|Unexpected token/i.test(failedOutput)) return ERROR_TYPES.SYNTAX_ERROR;
  if (/TypeError|is not a function|undefined/i.test(failedOutput)) return ERROR_TYPES.TYPE_ERROR;
  if (/Cannot find module|import.*from/i.test(failedOutput)) return ERROR_TYPES.IMPORT_ERROR;
  if (/FAIL|test.*failed|expect.*toBe/i.test(failedOutput)) return ERROR_TYPES.TEST_FAILURE;
  if (/build failed|compilation error/i.test(failedOutput)) return ERROR_TYPES.BUILD_FAILURE;
  if (/timeout|SIGTERM/i.test(failedOutput)) return ERROR_TYPES.TIMEOUT;

  return ERROR_TYPES.UNKNOWN;
};

// Buscar estrat√©gia que funcionou
const getProvenStrategy = (errorType) => {
  const dbPath = path.join(process.cwd(), FAILURE_DB_PATH);

  if (!fs.existsSync(dbPath)) return null;

  const patterns = JSON.parse(fs.readFileSync(dbPath, 'utf-8'));

  const successful = patterns
    .filter(p => p.errorType === errorType && p.recovered === true)
    .sort((a, b) => b.successRate - a.successRate);

  return successful[0] || null;
};

// Registrar tentativa de recupera√ß√£o
const recordRecoveryAttempt = async (errorType, succeeded, strategyUsed) => {
  const dbPath = path.join(process.cwd(), FAILURE_DB_PATH);

  let patterns = [];
  if (fs.existsSync(dbPath)) {
    patterns = JSON.parse(fs.readFileSync(dbPath, 'utf-8'));
  }

  // Atualizar ou adicionar padr√£o
  const existing = patterns.find(p =>
    p.errorType === errorType && p.strategy === strategyUsed
  );

  if (existing) {
    existing.attempts++;
    if (succeeded) existing.successes++;
    existing.successRate = existing.successes / existing.attempts;
  } else {
    patterns.push({
      errorType,
      strategy: strategyUsed,
      attempts: 1,
      successes: succeeded ? 1 : 0,
      successRate: succeeded ? 1 : 0,
      recovered: succeeded,
      lastUsed: new Date().toISOString()
    });
  }

  fs.writeFileSync(dbPath, JSON.stringify(patterns, null, 2));
};

// Executar fallback com aprendizado
const executeLearningFallback = async (task, failedOutput, executeClaude) => {
  const errorType = await classifyError(failedOutput);
  const provenStrategy = getProvenStrategy(errorType);

  const fallbackPrompt = `
## AN√ÅLISE DE FALHA

**Tipo de erro detectado:** ${errorType}

### Output do Agente que Falhou (√∫ltimos 2000 chars):
\`\`\`
${failedOutput.slice(-2000)}
\`\`\`

${provenStrategy ? `
## ESTRAT√âGIA COMPROVADA

Esta estrat√©gia funcionou **${(provenStrategy.successRate * 100).toFixed(0)}%** das vezes para este tipo de erro:

**Abordagem:** ${provenStrategy.strategy}

**Instru√ß√µes:**
1. Analise o erro acima
2. Aplique a estrat√©gia comprovada
3. Verifique se a corre√ß√£o resolve o problema
` : `
## NOVA ESTRAT√âGIA NECESS√ÅRIA

N√£o h√° estrat√©gia comprovada para este tipo de erro ainda.

**Instru√ß√µes:**
1. Analise a causa raiz do erro
2. Proponha uma abordagem de corre√ß√£o
3. Documente a estrat√©gia usada para aprendizado futuro
`}

## CONTEXTO DA TAREFA
${fs.readFileSync(path.join(task, 'TODO.md'), 'utf-8').slice(0, 3000)}
`;

  const result = await executeClaude(fallbackPrompt, task);

  // Registrar para aprendizado
  const strategyUsed = provenStrategy?.strategy || 'new_strategy_attempted';
  await recordRecoveryAttempt(errorType, result.success, strategyUsed);

  return result;
};

module.exports = {
  classifyError,
  getProvenStrategy,
  recordRecoveryAttempt,
  executeLearningFallback,
  ERROR_TYPES
};
```

**Novo arquivo:** `src/shared/services/fallback-learning/index.test.js`

```javascript
const { classifyError, ERROR_TYPES } = require('./index');

describe('fallback-learning', () => {
  describe('classifyError', () => {
    test('should detect syntax errors', async () => {
      const output = 'SyntaxError: Unexpected token }';
      const result = await classifyError(output);
      expect(result).toBe(ERROR_TYPES.SYNTAX_ERROR);
    });

    test('should detect type errors', async () => {
      const output = 'TypeError: undefined is not a function';
      const result = await classifyError(output);
      expect(result).toBe(ERROR_TYPES.TYPE_ERROR);
    });

    test('should detect test failures', async () => {
      const output = 'FAIL src/test.js\nexpect(received).toBe(expected)';
      const result = await classifyError(output);
      expect(result).toBe(ERROR_TYPES.TEST_FAILURE);
    });
  });
});
```

### Integra√ß√£o no Step5

**Arquivo:** `src/commands/task-executor/steps/step5/index.js`

```javascript
const { executeLearningFallback } = require('../../../../shared/services/fallback-learning');

// No catch de erro ou ap√≥s detectar falha:
if (taskFailed) {
  logger.info('Executing learning fallback...');
  const fallbackResult = await executeLearningFallback(
    taskFolder,
    failedOutput,
    executeClaude
  );

  if (fallbackResult.success) {
    logger.success('Fallback recovered the task!');
  }
}
```

### Ganhos Estimados
- **Taxa de recupera√ß√£o:** +40-50% (estrat√©gias comprovadas)
- **Tempo de debug:** -60% (n√£o reinicia do zero)

---

## 3. Cross-Task Learning

### O Que √â
Sistema que indexa solu√ß√µes de tarefas completadas e sugere abordagens para tarefas similares.

### Como Implementar

**Novo arquivo:** `src/shared/services/cross-task-learning/index.js`

```javascript
const fs = require('fs');
const path = require('path');
const { getLocalLLMService } = require('../local-llm');

const SOLUTIONS_DB = '.claudiomiro/cache/solutions-library.json';

// Indexar tarefa completada
const indexCompletedTask = async (taskPath) => {
  const taskMd = fs.readFileSync(path.join(taskPath, 'TASK.md'), 'utf-8');
  const contextMd = fs.existsSync(path.join(taskPath, 'CONTEXT.md'))
    ? fs.readFileSync(path.join(taskPath, 'CONTEXT.md'), 'utf-8')
    : '';

  // Extrair informa√ß√µes
  const solution = {
    id: path.basename(taskPath),
    description: extractDescription(taskMd),
    approach: extractApproach(contextMd),
    filesModified: extractFilesModified(contextMd),
    patterns: extractPatterns(contextMd),
    keywords: extractKeywords(taskMd + contextMd),
    timestamp: new Date().toISOString()
  };

  // Salvar no banco
  const dbPath = path.join(process.cwd(), SOLUTIONS_DB);
  let library = [];

  if (fs.existsSync(dbPath)) {
    library = JSON.parse(fs.readFileSync(dbPath, 'utf-8'));
  }

  // Evitar duplicatas
  library = library.filter(s => s.id !== solution.id);
  library.push(solution);

  fs.writeFileSync(dbPath, JSON.stringify(library, null, 2));

  return solution;
};

// Encontrar solu√ß√µes similares
const findSimilarSolutions = async (taskDescription, maxResults = 3) => {
  const dbPath = path.join(process.cwd(), SOLUTIONS_DB);

  if (!fs.existsSync(dbPath)) return [];

  const library = JSON.parse(fs.readFileSync(dbPath, 'utf-8'));

  if (library.length === 0) return [];

  // Tentar com Local LLM
  const llm = getLocalLLMService();
  if (llm && llm.isAvailable()) {
    try {
      const ranked = await llm.rankBySimilarity(
        library.map(s => s.description),
        taskDescription
      );

      return ranked
        .slice(0, maxResults)
        .map(r => library.find(s => s.description === r.text))
        .filter(Boolean);
    } catch (e) {
      // Fallback para keyword matching
    }
  }

  // Fallback: keyword matching
  const taskKeywords = extractKeywords(taskDescription);

  const scored = library.map(solution => {
    const matchCount = solution.keywords.filter(k =>
      taskKeywords.some(tk => tk.toLowerCase().includes(k.toLowerCase()))
    ).length;

    return {
      ...solution,
      score: matchCount / Math.max(solution.keywords.length, 1)
    };
  });

  return scored
    .filter(s => s.score > 0.2)
    .sort((a, b) => b.score - a.score)
    .slice(0, maxResults);
};

// Gerar prompt com solu√ß√µes similares
const buildCrossTaskPrompt = async (taskDescription, basePrompt) => {
  const similar = await findSimilarSolutions(taskDescription);

  if (similar.length === 0) {
    return basePrompt;
  }

  const similarSection = `
## SOLU√á√ïES SIMILARES ANTERIORES

Tarefas similares j√° foram resolvidas neste projeto. Use como refer√™ncia:

${similar.map((s, i) => `
### Solu√ß√£o ${i + 1}: ${s.description.slice(0, 100)}...

**Abordagem:** ${s.approach}

**Arquivos modificados:** ${s.filesModified.slice(0, 5).join(', ')}

**Padr√µes usados:** ${s.patterns.join(', ')}
`).join('\n---\n')}

---

`;

  return similarSection + basePrompt;
};

// Helpers
const extractDescription = (md) => {
  const match = md.match(/^#\s+(.+)/m);
  return match ? match[1] : md.slice(0, 200);
};

const extractApproach = (md) => {
  const match = md.match(/## (?:Approach|Abordagem|Implementation)\s*\n([\s\S]*?)(?=\n##|$)/i);
  return match ? match[1].trim().slice(0, 500) : '';
};

const extractFilesModified = (md) => {
  const matches = md.match(/(?:modified|created|updated|alterado|criado).*?`([^`]+)`/gi) || [];
  return [...new Set(matches.map(m => m.match(/`([^`]+)`/)?.[1]).filter(Boolean))];
};

const extractPatterns = (md) => {
  const patterns = [];
  if (/factory|Factory/i.test(md)) patterns.push('factory');
  if (/singleton|Singleton/i.test(md)) patterns.push('singleton');
  if (/repository|Repository/i.test(md)) patterns.push('repository');
  if (/service|Service/i.test(md)) patterns.push('service');
  if (/middleware|Middleware/i.test(md)) patterns.push('middleware');
  if (/hook|Hook/i.test(md)) patterns.push('hook');
  if (/component|Component/i.test(md)) patterns.push('component');
  return patterns;
};

const extractKeywords = (text) => {
  const words = text.toLowerCase()
    .replace(/[^a-z0-9\s]/g, ' ')
    .split(/\s+/)
    .filter(w => w.length > 3);

  return [...new Set(words)].slice(0, 50);
};

module.exports = {
  indexCompletedTask,
  findSimilarSolutions,
  buildCrossTaskPrompt
};
```

### Integra√ß√£o

**Arquivo:** `src/commands/task-executor/steps/step6/index.js` (ap√≥s commit bem-sucedido)

```javascript
const { indexCompletedTask } = require('../../../../shared/services/cross-task-learning');

// Ap√≥s task completada com sucesso:
await indexCompletedTask(taskFolder);
logger.debug('Task indexed for future learning');
```

**Arquivo:** `src/commands/task-executor/steps/step5/index.js`

```javascript
const { buildCrossTaskPrompt } = require('../../../../shared/services/cross-task-learning');

// Ao construir o prompt:
const enhancedPrompt = await buildCrossTaskPrompt(taskDescription, basePrompt);
```

### Ganhos Estimados
- **Consist√™ncia:** +30% (segue padr√µes do projeto)
- **Velocidade:** +15-20% (n√£o reinventa solu√ß√µes)

---

## 4. Context-Aware Instructions

### O Que √â
Sistema que detecta o stack do projeto e injeta instru√ß√µes espec√≠ficas automaticamente.

### Como Implementar

**Novo arquivo:** `src/shared/services/adaptive-instructions/index.js`

```javascript
const fs = require('fs');
const path = require('path');

// Detectar padr√µes do projeto
const detectProjectStack = async (projectPath) => {
  const hasFile = (name) => {
    if (name.includes('*')) {
      const dir = path.dirname(name);
      const pattern = path.basename(name).replace('*', '');
      try {
        const files = fs.readdirSync(path.join(projectPath, dir));
        return files.some(f => f.includes(pattern));
      } catch { return false; }
    }
    return fs.existsSync(path.join(projectPath, name));
  };

  const hasDependency = (dep) => {
    try {
      const pkg = JSON.parse(fs.readFileSync(path.join(projectPath, 'package.json'), 'utf-8'));
      return !!(pkg.dependencies?.[dep] || pkg.devDependencies?.[dep]);
    } catch { return false; }
  };

  return {
    typescript: hasFile('tsconfig.json'),
    javascript: hasFile('package.json') && !hasFile('tsconfig.json'),
    jest: hasFile('jest.config.js') || hasFile('jest.config.ts') || hasDependency('jest'),
    vitest: hasDependency('vitest'),
    eslint: hasFile('.eslintrc*') || hasFile('eslint.config.*'),
    prettier: hasFile('.prettierrc*') || hasFile('prettier.config.*'),
    react: hasDependency('react'),
    vue: hasDependency('vue'),
    angular: hasDependency('@angular/core'),
    nestjs: hasDependency('@nestjs/core'),
    express: hasDependency('express'),
    nextjs: hasDependency('next'),
    monorepo: hasFile('lerna.json') || hasFile('pnpm-workspace.yaml') || hasFile('nx.json'),
    docker: hasFile('Dockerfile') || hasFile('docker-compose.yml'),
  };
};

// M√≥dulos de instru√ß√µes por stack
const INSTRUCTION_MODULES = {
  typescript: `
## TypeScript Rules
- Use explicit types, avoid \`any\`
- Prefer interfaces for objects, types for unions
- Enable strict null checks compliance
- Use readonly where applicable
`,

  jest: `
## Testing Rules (Jest)
- Every new function needs a corresponding test
- Use describe/it/expect pattern
- Mock external dependencies with jest.mock()
- Aim for >80% coverage on new code
`,

  vitest: `
## Testing Rules (Vitest)
- Use describe/it/expect pattern
- Prefer vi.mock() for mocking
- Use vi.spyOn() for function spies
`,

  react: `
## React Rules
- Prefer functional components with hooks
- Use React.memo() for expensive renders
- Follow naming: PascalCase for components
- Extract reusable logic into custom hooks
`,

  nestjs: `
## NestJS Rules
- Use dependency injection (constructor injection)
- Follow module/controller/service pattern
- Use class-validator decorators for DTOs
- Handle errors with exception filters
`,

  nextjs: `
## Next.js Rules
- Prefer Server Components when possible
- Use 'use client' only when needed
- Follow app router conventions
- Use next/image for images
`,

  monorepo: `
## Monorepo Rules
- Respect package boundaries
- Import from package names, not relative paths
- Check if changes affect other packages
`,

  eslint: `
## Code Style
- Follow existing ESLint rules
- Run lint before committing
- Fix warnings, not just errors
`,

  prettier: `
## Formatting
- Code will be auto-formatted by Prettier
- Don't fight the formatter
`,
};

// Construir instru√ß√µes adaptativas
const buildAdaptiveInstructions = async (projectPath) => {
  const stack = await detectProjectStack(projectPath);

  const instructions = Object.entries(stack)
    .filter(([_, detected]) => detected)
    .map(([key]) => INSTRUCTION_MODULES[key])
    .filter(Boolean)
    .join('\n');

  if (!instructions) {
    return '## General Rules\n- Follow existing code patterns\n- Write clean, readable code\n';
  }

  return `# PROJECT-SPECIFIC INSTRUCTIONS\n\n${instructions}`;
};

module.exports = {
  detectProjectStack,
  buildAdaptiveInstructions,
  INSTRUCTION_MODULES
};
```

### Integra√ß√£o

**Arquivo:** `src/commands/task-executor/steps/step5/index.js`

```javascript
const { buildAdaptiveInstructions } = require('../../../../shared/services/adaptive-instructions');

// No in√≠cio da constru√ß√£o do prompt:
const stackInstructions = await buildAdaptiveInstructions(state.folder);

const enhancedPrompt = `
${stackInstructions}

---

${basePrompt}
`;
```

### Ganhos Estimados
- **Conformidade:** +20% (segue regras do stack)
- **Erros de lint/type:** -40% (instru√ß√µes espec√≠ficas)

---

## 5. Confidence-Based Checkpoints

### O Que √â
Sistema que detecta quando a IA expressa incerteza e oferece checkpoint para revis√£o.

### Como Implementar

**Novo arquivo:** `src/shared/services/confidence-detector/index.js`

```javascript
// Padr√µes que indicam incerteza
const UNCERTAINTY_PATTERNS = [
  /i'm not (entirely )?sure/i,
  /might need( to be)? review/i,
  /could be wrong/i,
  /uncertain about/i,
  /this (may|might|could) (need|require)/i,
  /please (verify|check|review)/i,
  /TODO:? ?(verify|check|confirm)/i,
  /not 100% (sure|certain|confident)/i,
  /i (think|believe|assume)/i,
  /probably|possibly|perhaps/i,
  /needs? (more )?testing/i,
  /edge case/i,
  /haven't tested/i,
];

// Detectar n√≠vel de confian√ßa
const detectConfidence = (output) => {
  const matches = UNCERTAINTY_PATTERNS
    .map(pattern => {
      const match = output.match(pattern);
      return match ? match[0] : null;
    })
    .filter(Boolean);

  const uncertaintyScore = matches.length / UNCERTAINTY_PATTERNS.length;
  const confidenceScore = 1 - uncertaintyScore;

  return {
    confidence: confidenceScore,
    uncertainty: uncertaintyScore,
    triggers: matches,
    shouldCheckpoint: uncertaintyScore > 0.25, // >25% incerteza
    level: confidenceScore > 0.8 ? 'high' :
           confidenceScore > 0.5 ? 'medium' : 'low'
  };
};

// Middleware para executar com checkpoints
const executeWithConfidenceCheck = async (executeFunc, task, options = {}) => {
  const result = await executeFunc(task);

  if (!options.enableConfidenceCheck) {
    return result;
  }

  const confidence = detectConfidence(result.output);

  if (confidence.shouldCheckpoint) {
    console.log(`\n‚ö†Ô∏è  AI expressed uncertainty (confidence: ${(confidence.confidence * 100).toFixed(0)}%)`);
    console.log(`   Triggers: ${confidence.triggers.slice(0, 3).join(', ')}`);

    if (options.onUncertainty) {
      const action = await options.onUncertainty(confidence, result);
      if (action === 'stop') {
        return { ...result, interrupted: true, reason: 'User review requested' };
      }
    }
  }

  return { ...result, confidence };
};

module.exports = {
  detectConfidence,
  executeWithConfidenceCheck,
  UNCERTAINTY_PATTERNS
};
```

### Integra√ß√£o

**Arquivo:** `src/commands/task-executor/steps/step5/index.js`

```javascript
const { detectConfidence } = require('../../../../shared/services/confidence-detector');
const readline = require('readline');

// Ap√≥s executar Claude:
const confidence = detectConfidence(output);

if (confidence.shouldCheckpoint && !state.options.autoApprove) {
  logger.warning(`‚ö†Ô∏è AI confidence: ${(confidence.confidence * 100).toFixed(0)}%`);
  logger.warning(`Triggers: ${confidence.triggers.join(', ')}`);

  const rl = readline.createInterface({ input: process.stdin, output: process.stdout });
  const answer = await new Promise(resolve => {
    rl.question('Review before continuing? (y/n): ', resolve);
  });
  rl.close();

  if (answer.toLowerCase() === 'y') {
    logger.info('Pausing for user review...');
    // Implementar l√≥gica de pausa/revis√£o
  }
}
```

### Ganhos Estimados
- **Bugs em produ√ß√£o:** -25% (revis√£o em pontos cr√≠ticos)
- **Confian√ßa do usu√°rio:** +30% (transpar√™ncia)

---

## 6. Predictive Behavior Control

### O Que √â
Sistema que prev√™ probabilidade de falha baseado em hist√≥rico de tarefas similares.

### Como Implementar

**Novo arquivo:** `src/shared/services/predictive-behavior/index.js`

```javascript
const fs = require('fs');
const path = require('path');

const HISTORY_DB = '.claudiomiro/cache/task-history.json';

// Registrar execu√ß√£o de tarefa
const recordTaskExecution = async (taskId, metrics) => {
  const dbPath = path.join(process.cwd(), HISTORY_DB);

  let history = [];
  if (fs.existsSync(dbPath)) {
    history = JSON.parse(fs.readFileSync(dbPath, 'utf-8'));
  }

  history.push({
    id: taskId,
    description: metrics.description,
    complexity: metrics.complexity,
    loopsRequired: metrics.loopsRequired,
    succeeded: metrics.succeeded,
    duration: metrics.duration,
    filesModified: metrics.filesModified,
    timestamp: new Date().toISOString()
  });

  // Manter √∫ltimas 500 tarefas
  if (history.length > 500) {
    history = history.slice(-500);
  }

  fs.writeFileSync(dbPath, JSON.stringify(history, null, 2));
};

// Prever probabilidade de retry
const predictRetryProbability = async (taskDescription, complexity = 'medium') => {
  const dbPath = path.join(process.cwd(), HISTORY_DB);

  if (!fs.existsSync(dbPath)) {
    return { probability: 0.3, reason: 'No history available', confidence: 'low' };
  }

  const history = JSON.parse(fs.readFileSync(dbPath, 'utf-8'));

  // Filtrar tarefas similares por complexidade
  const similarComplexity = history.filter(t => t.complexity === complexity);

  if (similarComplexity.length < 5) {
    return { probability: 0.3, reason: 'Insufficient data', confidence: 'low' };
  }

  // Calcular taxa de retry
  const withRetry = similarComplexity.filter(t => t.loopsRequired > 0);
  const retryRate = withRetry.length / similarComplexity.length;
  const avgLoops = withRetry.reduce((sum, t) => sum + t.loopsRequired, 0) / Math.max(withRetry.length, 1);

  return {
    probability: retryRate,
    expectedLoops: Math.ceil(avgLoops),
    reason: `${(retryRate * 100).toFixed(0)}% of ${complexity} tasks required retry`,
    confidence: similarComplexity.length > 20 ? 'high' : 'medium',
    sampleSize: similarComplexity.length
  };
};

// Sugerir a√ß√£o baseado na previs√£o
const suggestAction = (prediction) => {
  if (prediction.probability > 0.7) {
    return {
      action: 'checkpoint',
      message: `High retry probability (${(prediction.probability * 100).toFixed(0)}%). Consider reviewing the plan first.`
    };
  }

  if (prediction.probability > 0.5) {
    return {
      action: 'warn',
      message: `Moderate retry probability. Expected ${prediction.expectedLoops} loops if retry needed.`
    };
  }

  return {
    action: 'continue',
    message: 'Low retry probability. Proceeding normally.'
  };
};

module.exports = {
  recordTaskExecution,
  predictRetryProbability,
  suggestAction
};
```

### Ganhos Estimados
- **Tempo desperdi√ßado:** -20% (antecipa problemas)
- **UX:** +25% (usu√°rio informado)

---

## 7. Semantic Anchors

### O Que √â
Sistema de anchors que vincula documenta√ß√£o a s√≠mbolos reais do Code Index.

### Como Implementar

**Novo arquivo:** `src/shared/services/semantic-anchors/index.js`

```javascript
const fs = require('fs');
const path = require('path');
const { getCodeIndex } = require('../code-index');

const MANIFEST_FILE = 'anchor-manifest.json';

// Criar anchor com v√≠nculo a s√≠mbolos
const createSemanticAnchor = async (anchorKey, file, linkedSymbols = []) => {
  const codeIndex = await getCodeIndex();

  // Validar que s√≠mbolos existem
  const validatedSymbols = [];
  for (const symbol of linkedSymbols) {
    const found = await codeIndex.findSymbol(symbol.name);
    if (found) {
      validatedSymbols.push({
        name: symbol.name,
        kind: found.kind,
        file: found.file,
        lineRange: found.lineRange
      });
    }
  }

  return {
    key: anchorKey,
    file,
    anchor: `<!-- anchor: ${anchorKey} -->`,
    linkedSymbols: validatedSymbols,
    createdAt: new Date().toISOString()
  };
};

// Carregar anchor com c√≥digo dos s√≠mbolos
const loadAnchorWithContext = async (claudiomiroFolder, anchorKey) => {
  const manifestPath = path.join(claudiomiroFolder, MANIFEST_FILE);

  if (!fs.existsSync(manifestPath)) return null;

  const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf-8'));
  const anchor = manifest.locations.find(l => l.key === anchorKey);

  if (!anchor) return null;

  // Ler conte√∫do do anchor
  const fileContent = fs.readFileSync(path.join(claudiomiroFolder, anchor.file), 'utf-8');
  const anchorContent = extractAnchorSection(fileContent, anchor.anchor);

  // Carregar c√≥digo dos s√≠mbolos vinculados
  const codeIndex = await getCodeIndex();
  const symbolsCode = await Promise.all(
    (anchor.linkedSymbols || []).map(async s => {
      const code = await codeIndex.getSymbolCode(s.name);
      return { ...s, code };
    })
  );

  return {
    documentation: anchorContent,
    linkedCode: symbolsCode
  };
};

const extractAnchorSection = (content, anchorTag) => {
  const startIdx = content.indexOf(anchorTag);
  if (startIdx === -1) return null;

  const afterAnchor = content.slice(startIdx + anchorTag.length);
  const nextAnchor = afterAnchor.match(/<!-- anchor: [a-z0-9-]+ -->/);

  return nextAnchor
    ? afterAnchor.slice(0, nextAnchor.index).trim()
    : afterAnchor.trim();
};

module.exports = {
  createSemanticAnchor,
  loadAnchorWithContext
};
```

### Ganhos Estimados
- **Relev√¢ncia contexto:** +25% (c√≥digo real, n√£o refer√™ncias)
- **Tokens economizados:** +10% (s√≥ carrega o necess√°rio)

---

## 8. Symbol-Linked Briefings

### O Que √â
Briefing packages que incluem c√≥digo real via Code Index em vez de apenas refer√™ncias textuais.

### Como Implementar

**Novo arquivo:** `src/shared/services/smart-briefing/index.js`

```javascript
const fs = require('fs');
const path = require('path');
const { getCodeIndex } = require('../code-index');

const generateSmartBriefing = async (taskFolder, taskDescription) => {
  const codeIndex = await getCodeIndex();

  if (!codeIndex) {
    // Fallback: briefing b√°sico sem Code Index
    return generateBasicBriefing(taskFolder, taskDescription);
  }

  // 1. Busca sem√¢ntica por s√≠mbolos relevantes
  const relevantSymbols = await codeIndex.semanticSearch(taskDescription, {
    maxResults: 10,
    minRelevance: 0.4
  });

  // 2. Tra√ßar depend√™ncias
  const dependencies = [];
  for (const symbol of relevantSymbols.slice(0, 5)) {
    const deps = await codeIndex.traceDependencies(symbol.name);
    dependencies.push(...deps);
  }

  // 3. Encontrar padr√µes similares
  const patterns = await codeIndex.findSimilarPatterns(taskDescription);

  // 4. Gerar briefing estruturado
  const briefing = {
    generated: new Date().toISOString(),
    task: taskDescription.slice(0, 500),

    relevantCode: await Promise.all(
      relevantSymbols.map(async s => ({
        name: s.name,
        kind: s.kind,
        file: s.file,
        relevance: s.relevance,
        code: await codeIndex.getSymbolCode(s.name),
        why: `Matches: ${s.matchReason || 'semantic similarity'}`
      }))
    ),

    dependencies: [...new Set(dependencies.map(d => `${d.from} -> ${d.to}`))],

    patterns: patterns.map(p => ({
      name: p.patternName,
      file: p.file,
      example: p.code.slice(0, 500),
      howToApply: p.hint
    })),

    suggestedApproach: generateApproachSuggestion(relevantSymbols, patterns)
  };

  // Salvar briefing
  const briefingPath = path.join(taskFolder, 'BRIEFING_PACKAGE.json');
  fs.writeFileSync(briefingPath, JSON.stringify(briefing, null, 2));

  return briefing;
};

const generateApproachSuggestion = (symbols, patterns) => {
  const suggestions = [];

  if (symbols.length > 0) {
    suggestions.push(`Reference existing implementation in ${symbols[0].file}`);
  }

  if (patterns.length > 0) {
    suggestions.push(`Follow ${patterns[0].patternName} pattern from ${patterns[0].file}`);
  }

  return suggestions.join('. ') || 'No specific approach suggested.';
};

const generateBasicBriefing = (taskFolder, taskDescription) => {
  return {
    generated: new Date().toISOString(),
    task: taskDescription,
    relevantCode: [],
    dependencies: [],
    patterns: [],
    suggestedApproach: 'Code Index not available. Explore codebase manually.',
    fallback: true
  };
};

module.exports = {
  generateSmartBriefing
};
```

### Ganhos Estimados
- **Contexto relevante:** +35% (c√≥digo real inclu√≠do)
- **Tempo de explora√ß√£o:** -40% (s√≠mbolos pr√©-encontrados)

---

## 9. Legacy Systems Reference

### O Que √â
Sistema que permite referenciar sistemas legados durante refatora√ß√£o, permitindo que o Claudiomiro consulte o c√≥digo antigo para entender funcionamento, regras de neg√≥cio e comportamentos antes de implementar no novo sistema.

### Flags de CLI

```bash
# Referenciar sistema legado completo
claudiomiro --legacy-system=/path/to/legacy-project "Refatorar m√≥dulo de pagamentos"

# Referenciar apenas backend legado
claudiomiro --legacy-backend=/path/to/legacy-api "Migrar API de autentica√ß√£o"

# Referenciar apenas frontend legado
claudiomiro --legacy-frontend=/path/to/legacy-ui "Recriar dashboard em React"

# M√∫ltiplos sistemas legados
claudiomiro \
  --legacy-backend=/path/to/old-api \
  --legacy-frontend=/path/to/old-ui \
  "Refatorar sistema de relat√≥rios"
```

### Casos de Uso

1. **Migra√ß√£o de Framework**: Migrar de Angular para React consultando componentes antigos
2. **Moderniza√ß√£o de API**: Recriar endpoints REST/GraphQL baseado em API SOAP
3. **Refatora√ß√£o de Monolito**: Extrair microservi√ßos entendendo o c√≥digo original
4. **Atualiza√ß√£o de Stack**: Migrar de jQuery para Vue consultando l√≥gica existente
5. **Documenta√ß√£o Reversa**: Entender regras de neg√≥cio do sistema antigo

### Como Implementar

**Arquivo:** `src/shared/config/cli-options.js`

```javascript
const legacyOptions = {
  'legacy-system': {
    alias: 'ls',
    type: 'string',
    description: 'Path to legacy system for reference during refactoring'
  },
  'legacy-backend': {
    alias: 'lb',
    type: 'string',
    description: 'Path to legacy backend for API/service reference'
  },
  'legacy-frontend': {
    alias: 'lf',
    type: 'string',
    description: 'Path to legacy frontend for UI/component reference'
  }
};

module.exports = { legacyOptions };
```

**Novo arquivo:** `src/shared/services/legacy-reference/index.js`

```javascript
const fs = require('fs');
const path = require('path');
const { IndexBuilder, QueryEngine } = require('../code-index');

class LegacyReferenceService {
  constructor() {
    this.legacySystems = new Map(); // path -> { index, type }
    this.initialized = false;
  }

  // Registrar sistema legado
  async registerLegacySystem(legacyPath, type = 'full') {
    if (!fs.existsSync(legacyPath)) {
      throw new Error(`Legacy system path not found: ${legacyPath}`);
    }

    console.log(`üì¶ Indexing legacy ${type} system: ${legacyPath}`);

    // Criar Code Index para o sistema legado
    const indexBuilder = new IndexBuilder({
      rootPath: legacyPath,
      cacheDir: path.join(legacyPath, '.claudiomiro-legacy-cache'),
      includePatterns: this.getPatternsForType(type)
    });

    const index = await indexBuilder.build();
    const queryEngine = new QueryEngine(index);

    this.legacySystems.set(legacyPath, {
      index,
      queryEngine,
      type,
      path: legacyPath,
      name: path.basename(legacyPath)
    });

    console.log(`‚úÖ Indexed ${index.symbols.length} symbols from legacy system`);

    return { symbolCount: index.symbols.length, path: legacyPath };
  }

  // Padr√µes de arquivo por tipo
  getPatternsForType(type) {
    switch (type) {
      case 'backend':
        return [
          '**/*.js', '**/*.ts', '**/*.py', '**/*.java', '**/*.go',
          '**/*.rb', '**/*.php', '**/*.cs', '**/*.rs',
          '**/package.json', '**/requirements.txt', '**/pom.xml'
        ];
      case 'frontend':
        return [
          '**/*.js', '**/*.ts', '**/*.jsx', '**/*.tsx', '**/*.vue',
          '**/*.svelte', '**/*.html', '**/*.css', '**/*.scss',
          '**/package.json'
        ];
      default: // full
        return ['**/*'];
    }
  }

  // Buscar implementa√ß√£o similar no legado
  async findLegacyImplementation(description, options = {}) {
    const results = [];

    for (const [legacyPath, legacy] of this.legacySystems) {
      const found = await legacy.queryEngine.semanticSearch(description, {
        maxResults: options.maxResults || 5,
        minRelevance: options.minRelevance || 0.3
      });

      results.push({
        legacySystem: legacy.name,
        legacyPath,
        type: legacy.type,
        matches: found.map(f => ({
          name: f.name,
          kind: f.kind,
          file: f.file,
          relativePath: path.relative(legacyPath, f.file),
          relevance: f.relevance,
          code: f.code
        }))
      });
    }

    return results;
  }

  // Buscar s√≠mbolo espec√≠fico no legado
  async findLegacySymbol(symbolName) {
    const results = [];

    for (const [legacyPath, legacy] of this.legacySystems) {
      const found = await legacy.queryEngine.findSymbol(symbolName);

      if (found) {
        results.push({
          legacySystem: legacy.name,
          legacyPath,
          symbol: found
        });
      }
    }

    return results;
  }

  // Tra√ßar como algo funciona no legado
  async traceLegacyFlow(entryPoint) {
    const results = [];

    for (const [legacyPath, legacy] of this.legacySystems) {
      const symbol = await legacy.queryEngine.findSymbol(entryPoint);

      if (symbol) {
        const dependencies = await legacy.queryEngine.traceDependencies(entryPoint);
        const callers = await legacy.queryEngine.findCallers(entryPoint);

        results.push({
          legacySystem: legacy.name,
          entryPoint: symbol,
          dependencies,
          callers,
          flowSummary: this.summarizeFlow(symbol, dependencies, callers)
        });
      }
    }

    return results;
  }

  // Resumir fluxo para o prompt
  summarizeFlow(symbol, deps, callers) {
    return {
      what: `${symbol.kind} ${symbol.name}`,
      where: symbol.file,
      uses: deps.slice(0, 10).map(d => d.to),
      usedBy: callers.slice(0, 10).map(c => c.name)
    };
  }

  // Gerar contexto de legado para o prompt
  async generateLegacyContext(taskDescription) {
    if (this.legacySystems.size === 0) {
      return null;
    }

    const implementations = await this.findLegacyImplementation(taskDescription);

    if (implementations.every(i => i.matches.length === 0)) {
      return null;
    }

    let context = `
## üì¶ LEGACY SYSTEM REFERENCE

The following implementations were found in legacy systems that may help understand the expected behavior:

`;

    for (const impl of implementations) {
      if (impl.matches.length === 0) continue;

      context += `
### Legacy ${impl.type.toUpperCase()}: ${impl.legacySystem}
Path: \`${impl.legacyPath}\`

`;

      for (const match of impl.matches.slice(0, 3)) {
        context += `
#### ${match.kind}: ${match.name}
**File:** \`${match.relativePath}\`
**Relevance:** ${(match.relevance * 100).toFixed(0)}%

\`\`\`
${match.code.slice(0, 1500)}
\`\`\`

`;
      }
    }

    context += `
---

**IMPORTANT:** Use the legacy code above as REFERENCE to understand:
- Business logic and rules
- Expected behavior and edge cases
- Data structures and formats
- Integration patterns

Do NOT copy legacy code directly. Implement using modern patterns while preserving the business logic.

---

`;

    return context;
  }

  // Verificar se h√° sistemas legados registrados
  hasLegacySystems() {
    return this.legacySystems.size > 0;
  }

  // Listar sistemas legados
  listLegacySystems() {
    return Array.from(this.legacySystems.entries()).map(([path, info]) => ({
      path,
      name: info.name,
      type: info.type,
      symbolCount: info.index.symbols.length
    }));
  }
}

// Singleton
let instance = null;

const getLegacyReferenceService = () => {
  if (!instance) {
    instance = new LegacyReferenceService();
  }
  return instance;
};

module.exports = {
  LegacyReferenceService,
  getLegacyReferenceService
};
```

**Novo arquivo:** `src/shared/services/legacy-reference/index.test.js`

```javascript
const { LegacyReferenceService } = require('./index');
const path = require('path');
const fs = require('fs');

// Mock do code-index
jest.mock('../code-index', () => ({
  IndexBuilder: jest.fn().mockImplementation(() => ({
    build: jest.fn().mockResolvedValue({
      symbols: [
        { name: 'processPayment', kind: 'function', file: '/legacy/payments.js' },
        { name: 'validateCard', kind: 'function', file: '/legacy/validation.js' }
      ]
    })
  })),
  QueryEngine: jest.fn().mockImplementation(() => ({
    semanticSearch: jest.fn().mockResolvedValue([
      { name: 'processPayment', kind: 'function', relevance: 0.85, code: 'function processPayment() {}' }
    ]),
    findSymbol: jest.fn().mockResolvedValue({ name: 'test', kind: 'function' }),
    traceDependencies: jest.fn().mockResolvedValue([]),
    findCallers: jest.fn().mockResolvedValue([])
  }))
}));

jest.mock('fs');

describe('LegacyReferenceService', () => {
  let service;

  beforeEach(() => {
    service = new LegacyReferenceService();
    fs.existsSync.mockReturnValue(true);
  });

  describe('registerLegacySystem', () => {
    test('should register a legacy system', async () => {
      const result = await service.registerLegacySystem('/path/to/legacy', 'backend');

      expect(result.symbolCount).toBe(2);
      expect(result.path).toBe('/path/to/legacy');
      expect(service.hasLegacySystems()).toBe(true);
    });

    test('should throw error if path not found', async () => {
      fs.existsSync.mockReturnValue(false);

      await expect(
        service.registerLegacySystem('/invalid/path')
      ).rejects.toThrow('Legacy system path not found');
    });
  });

  describe('findLegacyImplementation', () => {
    test('should find implementations across legacy systems', async () => {
      await service.registerLegacySystem('/legacy', 'full');

      const results = await service.findLegacyImplementation('payment processing');

      expect(results).toHaveLength(1);
      expect(results[0].matches).toHaveLength(1);
      expect(results[0].matches[0].name).toBe('processPayment');
    });
  });

  describe('generateLegacyContext', () => {
    test('should generate context for prompt', async () => {
      await service.registerLegacySystem('/legacy', 'backend');

      const context = await service.generateLegacyContext('implement payment');

      expect(context).toContain('LEGACY SYSTEM REFERENCE');
      expect(context).toContain('processPayment');
    });

    test('should return null if no legacy systems', async () => {
      const context = await service.generateLegacyContext('test');
      expect(context).toBeNull();
    });
  });
});
```

### Integra√ß√£o no CLI

**Arquivo:** `src/commands/task-executor/index.js`

```javascript
const { getLegacyReferenceService } = require('../../shared/services/legacy-reference');

// No in√≠cio da execu√ß√£o:
const initializeLegacySystems = async (options) => {
  const legacyService = getLegacyReferenceService();

  if (options.legacySystem) {
    await legacyService.registerLegacySystem(options.legacySystem, 'full');
  }

  if (options.legacyBackend) {
    await legacyService.registerLegacySystem(options.legacyBackend, 'backend');
  }

  if (options.legacyFrontend) {
    await legacyService.registerLegacySystem(options.legacyFrontend, 'frontend');
  }

  if (legacyService.hasLegacySystems()) {
    const systems = legacyService.listLegacySystems();
    logger.info(`üì¶ Legacy systems registered: ${systems.map(s => s.name).join(', ')}`);
  }
};
```

### Integra√ß√£o nos Steps

**Arquivo:** `src/commands/task-executor/steps/step5/index.js`

```javascript
const { getLegacyReferenceService } = require('../../../../shared/services/legacy-reference');

// Ao construir o prompt:
const buildPromptWithLegacy = async (taskDescription, basePrompt) => {
  const legacyService = getLegacyReferenceService();

  if (!legacyService.hasLegacySystems()) {
    return basePrompt;
  }

  const legacyContext = await legacyService.generateLegacyContext(taskDescription);

  if (!legacyContext) {
    return basePrompt;
  }

  return `${legacyContext}\n\n${basePrompt}`;
};

// Uso:
const prompt = await buildPromptWithLegacy(taskDescription, basePrompt);
await executeClaude(prompt, task);
```

### Integra√ß√£o com Three-Phase Generation

```markdown
## FASE 0: DESCOBERTA INTELIGENTE

Antes de planejar, analise AMBOS os sistemas:

### Sistema Atual (onde voc√™ vai implementar)
1. Busque s√≠mbolos relacionados √† tarefa
2. Identifique padr√µes existentes
3. Mapeie depend√™ncias

### Sistema Legado (refer√™ncia)
1. Como essa funcionalidade funciona no legado?
2. Quais regras de neg√≥cio est√£o implementadas?
3. Quais edge cases s√£o tratados?
4. Quais integra√ß√µes existem?

**OUTPUT FASE 0:**
- Padr√µes do sistema atual
- Comportamentos do sistema legado a preservar
- Diferen√ßas de arquitetura a considerar
```

### Comandos √öteis para o Prompt

O Claudiomiro pode instruir a IA a fazer consultas espec√≠ficas no legado:

```markdown
## LEGACY QUERY COMMANDS

Durante a implementa√ß√£o, voc√™ pode consultar o sistema legado:

1. **Buscar implementa√ß√£o similar:**
   "Consultar legado: como funciona o processamento de pagamentos?"

2. **Entender fluxo:**
   "Tra√ßar fluxo legado: fun√ß√£o validateOrder"

3. **Verificar regra de neg√≥cio:**
   "Verificar legado: regras de desconto para clientes VIP"

O Claudiomiro ir√° buscar no c√≥digo legado e incluir o contexto relevante.
```

### Exemplo de Output no Prompt

Quando o usu√°rio executa:
```bash
claudiomiro --legacy-backend=/old-api "Refatorar endpoint de login"
```

O prompt incluir√°:

```markdown
## üì¶ LEGACY SYSTEM REFERENCE

The following implementations were found in legacy systems that may help understand the expected behavior:

### Legacy BACKEND: old-api
Path: `/old-api`

#### function: authenticateUser
**File:** `src/auth/login.js`
**Relevance:** 92%

```javascript
async function authenticateUser(email, password) {
  // Validate input
  if (!email || !password) {
    throw new ValidationError('Email and password required');
  }

  // Find user
  const user = await User.findByEmail(email);
  if (!user) {
    throw new AuthError('Invalid credentials'); // Don't reveal if user exists
  }

  // Check password
  const isValid = await bcrypt.compare(password, user.passwordHash);
  if (!isValid) {
    await logFailedAttempt(email); // Security: log failed attempts
    throw new AuthError('Invalid credentials');
  }

  // Check account status
  if (user.status === 'suspended') {
    throw new AuthError('Account suspended');
  }

  // Generate token
  const token = jwt.sign({ userId: user.id, role: user.role }, SECRET, { expiresIn: '24h' });

  // Update last login
  await user.updateLastLogin();

  return { token, user: sanitizeUser(user) };
}
```

---

**IMPORTANT:** Use the legacy code above as REFERENCE to understand:
- Business logic and rules (validation, security logging, account status check)
- Expected behavior (don't reveal if user exists)
- Security patterns (failed attempt logging)

Do NOT copy legacy code directly. Implement using modern patterns while preserving the business logic.
```

### Ganhos Estimados
- **Precis√£o em refatora√ß√£o:** +50-70% (entende comportamento esperado)
- **Bugs de regress√£o:** -60% (preserva regras de neg√≥cio)
- **Tempo de an√°lise:** -40% (c√≥digo legado pr√©-indexado)
- **Documenta√ß√£o impl√≠cita:** +80% (c√≥digo legado serve como spec)

---

## 10. Multi-Model Orchestration

### O Que √â
Sistema que roteia automaticamente cada tarefa para o modelo de IA mais apropriado, otimizando custo e velocidade sem sacrificar qualidade.

### O Problema
- Usar Claude Opus para tudo √© caro (~$15/1M tokens input)
- Tarefas simples (fix typo, add comment) n√£o precisam do modelo mais potente
- Claude Haiku √© 60x mais barato e 10x mais r√°pido
- Desperd√≠cio de recursos e tempo em tarefas triviais

### A Solu√ß√£o
Classificar tarefas automaticamente e rotear para o modelo ideal.

### Como Implementar

**Novo arquivo:** `src/shared/services/model-router/index.js`

```javascript
const { getLocalLLMService } = require('../local-llm');

// Configura√ß√£o de modelos dispon√≠veis
const MODELS = {
  fast: {
    name: 'claude-haiku',
    id: 'claude-3-haiku-20240307',
    costPer1kTokens: 0.00025,
    speedMultiplier: 10,
    maxComplexity: 'simple'
  },
  balanced: {
    name: 'claude-sonnet',
    id: 'claude-3-5-sonnet-20241022',
    costPer1kTokens: 0.003,
    speedMultiplier: 3,
    maxComplexity: 'medium'
  },
  powerful: {
    name: 'claude-opus',
    id: 'claude-3-opus-20240229',
    costPer1kTokens: 0.015,
    speedMultiplier: 1,
    maxComplexity: 'complex'
  }
};

// Padr√µes para classifica√ß√£o de complexidade
const COMPLEXITY_PATTERNS = {
  simple: [
    /fix\s*(typo|spelling|whitespace)/i,
    /add\s*(comment|log|console)/i,
    /rename\s*(variable|function|file)/i,
    /format\s*(code|file)/i,
    /remove\s*(unused|dead\s*code)/i,
    /update\s*(version|dependency)/i,
    /change\s*(string|text|message)/i
  ],
  medium: [
    /add\s*(function|method|class)/i,
    /write\s*(test|spec)/i,
    /refactor\s*(method|function)/i,
    /implement\s*(feature|endpoint)/i,
    /fix\s*(bug|error|issue)/i,
    /create\s*(component|service)/i,
    /update\s*(logic|validation)/i
  ],
  complex: [
    /architect/i,
    /design\s*(system|pattern)/i,
    /security\s*(audit|review|fix)/i,
    /performance\s*(optimization|tuning)/i,
    /migrate\s*(database|system|architecture)/i,
    /complex\s*(algorithm|logic)/i,
    /refactor\s*(entire|complete|whole)/i,
    /integrate\s*(multiple|complex)/i
  ]
};

// Classificar complexidade da tarefa
const classifyTaskComplexity = async (taskDescription) => {
  // 1. Tentar com Local LLM para classifica√ß√£o sem√¢ntica
  const llm = getLocalLLMService();

  if (llm && llm.isAvailable()) {
    try {
      const result = await llm.classify(taskDescription, ['simple', 'medium', 'complex']);
      if (result && result.confidence > 0.7) {
        return {
          complexity: result.label,
          confidence: result.confidence,
          method: 'llm'
        };
      }
    } catch (e) {
      // Fallback para regex
    }
  }

  // 2. Fallback: pattern matching
  for (const [complexity, patterns] of Object.entries(COMPLEXITY_PATTERNS)) {
    for (const pattern of patterns) {
      if (pattern.test(taskDescription)) {
        return {
          complexity,
          confidence: 0.8,
          method: 'pattern',
          matchedPattern: pattern.source
        };
      }
    }
  }

  // 3. Default: medium (safe choice)
  return {
    complexity: 'medium',
    confidence: 0.5,
    method: 'default'
  };
};

// Selecionar modelo baseado na complexidade
const selectModel = async (taskDescription, options = {}) => {
  // Permitir override manual
  if (options.forceModel) {
    const model = Object.values(MODELS).find(m => m.name === options.forceModel);
    if (model) {
      return { model, reason: 'forced by user', classification: null };
    }
  }

  const classification = await classifyTaskComplexity(taskDescription);

  // Mapear complexidade para modelo
  const modelMap = {
    simple: MODELS.fast,
    medium: MODELS.balanced,
    complex: MODELS.powerful
  };

  const selectedModel = modelMap[classification.complexity];

  return {
    model: selectedModel,
    reason: `Task classified as ${classification.complexity} (${classification.method}, ${(classification.confidence * 100).toFixed(0)}% confidence)`,
    classification
  };
};

// Calcular economia estimada
const calculateSavings = (tasksExecuted) => {
  const withoutOrchestration = tasksExecuted.reduce((sum, t) =>
    sum + (t.tokens * MODELS.powerful.costPer1kTokens / 1000), 0
  );

  const withOrchestration = tasksExecuted.reduce((sum, t) =>
    sum + (t.tokens * t.modelUsed.costPer1kTokens / 1000), 0
  );

  return {
    withoutOrchestration,
    withOrchestration,
    saved: withoutOrchestration - withOrchestration,
    percentageSaved: ((withoutOrchestration - withOrchestration) / withoutOrchestration * 100).toFixed(1)
  };
};

// Registrar uso para m√©tricas
const usageStats = {
  tasks: [],

  record(taskDescription, model, tokens, success) {
    this.tasks.push({
      timestamp: new Date().toISOString(),
      model,
      tokens,
      success,
      description: taskDescription.slice(0, 100)
    });
  },

  getSummary() {
    const byModel = {};
    for (const task of this.tasks) {
      const name = task.model.name;
      if (!byModel[name]) {
        byModel[name] = { count: 0, tokens: 0, successes: 0 };
      }
      byModel[name].count++;
      byModel[name].tokens += task.tokens;
      if (task.success) byModel[name].successes++;
    }

    return {
      totalTasks: this.tasks.length,
      byModel,
      savings: calculateSavings(this.tasks.map(t => ({
        tokens: t.tokens,
        modelUsed: t.model
      })))
    };
  }
};

module.exports = {
  MODELS,
  classifyTaskComplexity,
  selectModel,
  calculateSavings,
  usageStats
};
```

**Novo arquivo:** `src/shared/services/model-router/index.test.js`

```javascript
const { classifyTaskComplexity, selectModel, MODELS } = require('./index');

describe('model-router', () => {
  describe('classifyTaskComplexity', () => {
    test('should classify typo fix as simple', async () => {
      const result = await classifyTaskComplexity('fix typo in README');
      expect(result.complexity).toBe('simple');
    });

    test('should classify add function as medium', async () => {
      const result = await classifyTaskComplexity('add function to validate email');
      expect(result.complexity).toBe('medium');
    });

    test('should classify architecture as complex', async () => {
      const result = await classifyTaskComplexity('architect new microservices system');
      expect(result.complexity).toBe('complex');
    });

    test('should default to medium for unknown tasks', async () => {
      const result = await classifyTaskComplexity('do something with the code');
      expect(result.complexity).toBe('medium');
    });
  });

  describe('selectModel', () => {
    test('should select haiku for simple tasks', async () => {
      const { model } = await selectModel('fix typo');
      expect(model.name).toBe('claude-haiku');
    });

    test('should select sonnet for medium tasks', async () => {
      const { model } = await selectModel('add new API endpoint');
      expect(model.name).toBe('claude-sonnet');
    });

    test('should select opus for complex tasks', async () => {
      const { model } = await selectModel('design security architecture');
      expect(model.name).toBe('claude-opus');
    });

    test('should respect forceModel option', async () => {
      const { model, reason } = await selectModel('fix typo', { forceModel: 'claude-opus' });
      expect(model.name).toBe('claude-opus');
      expect(reason).toBe('forced by user');
    });
  });
});
```

### Integra√ß√£o no Executor

**Arquivo:** `src/services/claude-executor.js`

```javascript
const { selectModel, usageStats } = require('../shared/services/model-router');

const executeClaude = async (prompt, task, options = {}) => {
  // Selecionar modelo apropriado
  const { model, reason, classification } = await selectModel(
    options.taskDescription || prompt.slice(0, 500),
    { forceModel: options.model }
  );

  logger.info(`üéØ Model selected: ${model.name} (${reason})`);

  // Executar com modelo selecionado
  const result = await executeWithModel(prompt, model.id, options);

  // Registrar para m√©tricas
  usageStats.record(
    options.taskDescription || 'unknown',
    model,
    result.tokensUsed,
    result.success
  );

  return result;
};
```

### CLI Flag para Override

```bash
# For√ßar modelo espec√≠fico
claudiomiro --model=opus "fix typo"  # Usa Opus mesmo para tarefa simples
claudiomiro --model=haiku "complex task"  # Usa Haiku (pode falhar)

# Ver estat√≠sticas de uso
claudiomiro --stats
```

### Ganhos Estimados
- **Custo:** -40-60% (maioria das tarefas usa modelos baratos)
- **Velocidade m√©dia:** +30-50% (Haiku √© 10x mais r√°pido)
- **Qualidade:** Mantida (tarefas complexas ainda usam Opus)

---

## 11. Incremental Verification

### O Que √â
Sistema que verifica cada mudan√ßa incrementalmente em vez de rodar todos os testes no final, detectando erros assim que s√£o introduzidos.

### O Problema
- Rodar todos os testes no final pode revelar 10+ erros
- Dif√≠cil saber qual mudan√ßa introduziu qual erro
- IA tenta corrigir tudo de uma vez e se perde
- Tempo perdido em cascata de erros

### A Solu√ß√£o
Verificar ap√≥s cada arquivo modificado. Parar e corrigir imediatamente.

### Como Implementar

**Novo arquivo:** `src/shared/services/incremental-verifier/index.js`

```javascript
const { spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

class IncrementalVerifier {
  constructor(projectPath, options = {}) {
    this.projectPath = projectPath;
    this.options = {
      runLint: options.runLint !== false,
      runTypeCheck: options.runTypeCheck !== false,
      runRelatedTests: options.runRelatedTests !== false,
      stopOnFirstError: options.stopOnFirstError !== false,
      ...options
    };
    this.errors = [];
    this.verified = new Set();
  }

  // Verificar um arquivo ap√≥s modifica√ß√£o
  async verifyFile(filePath) {
    const relativePath = path.relative(this.projectPath, filePath);

    if (this.verified.has(filePath)) {
      return { success: true, skipped: true };
    }

    console.log(`üîç Verifying: ${relativePath}`);

    const results = {
      file: relativePath,
      lint: null,
      typeCheck: null,
      tests: null,
      success: true,
      errors: []
    };

    // 1. Lint do arquivo
    if (this.options.runLint) {
      results.lint = await this.runLint(filePath);
      if (!results.lint.success) {
        results.success = false;
        results.errors.push(...results.lint.errors);

        if (this.options.stopOnFirstError) {
          return results;
        }
      }
    }

    // 2. Type check incremental
    if (this.options.runTypeCheck && this.isTypeScriptProject()) {
      results.typeCheck = await this.runTypeCheck(filePath);
      if (!results.typeCheck.success) {
        results.success = false;
        results.errors.push(...results.typeCheck.errors);

        if (this.options.stopOnFirstError) {
          return results;
        }
      }
    }

    // 3. Testes relacionados
    if (this.options.runRelatedTests) {
      const relatedTests = await this.findRelatedTests(filePath);

      if (relatedTests.length > 0) {
        results.tests = await this.runTests(relatedTests);
        if (!results.tests.success) {
          results.success = false;
          results.errors.push(...results.tests.errors);
        }
      }
    }

    this.verified.add(filePath);

    if (!results.success) {
      this.errors.push(results);
    }

    return results;
  }

  // Executar lint
  async runLint(filePath) {
    return new Promise((resolve) => {
      const ext = path.extname(filePath);
      let lintCommand, lintArgs;

      if (['.js', '.jsx', '.ts', '.tsx'].includes(ext)) {
        lintCommand = 'npx';
        lintArgs = ['eslint', '--format', 'json', filePath];
      } else {
        resolve({ success: true, skipped: true });
        return;
      }

      const proc = spawn(lintCommand, lintArgs, { cwd: this.projectPath });
      let output = '';

      proc.stdout.on('data', (data) => { output += data; });
      proc.stderr.on('data', (data) => { output += data; });

      proc.on('close', (code) => {
        if (code === 0) {
          resolve({ success: true, errors: [] });
        } else {
          let errors = [];
          try {
            const parsed = JSON.parse(output);
            errors = parsed.flatMap(f => f.messages.map(m => ({
              file: f.filePath,
              line: m.line,
              column: m.column,
              message: m.message,
              rule: m.ruleId,
              severity: m.severity === 2 ? 'error' : 'warning'
            })));
          } catch {
            errors = [{ message: output, file: filePath }];
          }

          resolve({ success: false, errors });
        }
      });
    });
  }

  // Executar type check
  async runTypeCheck(filePath) {
    return new Promise((resolve) => {
      const proc = spawn('npx', ['tsc', '--noEmit', '--incremental'], {
        cwd: this.projectPath
      });

      let output = '';
      proc.stdout.on('data', (data) => { output += data; });
      proc.stderr.on('data', (data) => { output += data; });

      proc.on('close', (code) => {
        if (code === 0) {
          resolve({ success: true, errors: [] });
        } else {
          const errors = this.parseTypeScriptErrors(output, filePath);
          resolve({ success: errors.length === 0, errors });
        }
      });
    });
  }

  // Parse erros do TypeScript
  parseTypeScriptErrors(output, relevantFile) {
    const errors = [];
    const lines = output.split('\n');
    const filePattern = new RegExp(relevantFile.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));

    for (const line of lines) {
      if (filePattern.test(line) && line.includes('error TS')) {
        const match = line.match(/(.+)\((\d+),(\d+)\): error (TS\d+): (.+)/);
        if (match) {
          errors.push({
            file: match[1],
            line: parseInt(match[2]),
            column: parseInt(match[3]),
            code: match[4],
            message: match[5]
          });
        }
      }
    }

    return errors;
  }

  // Encontrar testes relacionados
  async findRelatedTests(filePath) {
    const basename = path.basename(filePath, path.extname(filePath));
    const dirname = path.dirname(filePath);

    const possibleTests = [
      path.join(dirname, `${basename}.test.js`),
      path.join(dirname, `${basename}.test.ts`),
      path.join(dirname, `${basename}.spec.js`),
      path.join(dirname, `${basename}.spec.ts`),
      path.join(dirname, '__tests__', `${basename}.test.js`),
      path.join(dirname, '__tests__', `${basename}.test.ts`)
    ];

    return possibleTests.filter(t => fs.existsSync(t));
  }

  // Executar testes
  async runTests(testFiles) {
    return new Promise((resolve) => {
      const proc = spawn('npx', ['jest', '--json', '--testPathPattern', testFiles.join('|')], {
        cwd: this.projectPath
      });

      let output = '';
      proc.stdout.on('data', (data) => { output += data; });
      proc.stderr.on('data', (data) => { output += data; });

      proc.on('close', (code) => {
        if (code === 0) {
          resolve({ success: true, errors: [] });
        } else {
          let errors = [];
          try {
            const jsonStart = output.indexOf('{');
            if (jsonStart !== -1) {
              const parsed = JSON.parse(output.slice(jsonStart));
              errors = parsed.testResults
                .filter(t => t.status === 'failed')
                .flatMap(t => t.assertionResults
                  .filter(a => a.status === 'failed')
                  .map(a => ({
                    file: t.name,
                    test: a.fullName,
                    message: a.failureMessages.join('\n')
                  }))
                );
            }
          } catch {
            errors = [{ message: output }];
          }

          resolve({ success: false, errors });
        }
      });
    });
  }

  // Verificar se √© projeto TypeScript
  isTypeScriptProject() {
    return fs.existsSync(path.join(this.projectPath, 'tsconfig.json'));
  }

  // Obter resumo de erros
  getSummary() {
    return {
      filesVerified: this.verified.size,
      filesWithErrors: this.errors.length,
      totalErrors: this.errors.reduce((sum, e) => sum + e.errors.length, 0),
      errors: this.errors
    };
  }

  // Resetar estado
  reset() {
    this.errors = [];
    this.verified.clear();
  }
}

// Factory function
const createVerifier = (projectPath, options) => {
  return new IncrementalVerifier(projectPath, options);
};

module.exports = {
  IncrementalVerifier,
  createVerifier
};
```

**Novo arquivo:** `src/shared/services/incremental-verifier/index.test.js`

```javascript
const { IncrementalVerifier } = require('./index');
const path = require('path');
const fs = require('fs');

jest.mock('child_process');
jest.mock('fs');

describe('IncrementalVerifier', () => {
  let verifier;

  beforeEach(() => {
    verifier = new IncrementalVerifier('/project', {
      runLint: true,
      runTypeCheck: false,
      runRelatedTests: true
    });
    fs.existsSync.mockReturnValue(false);
  });

  describe('findRelatedTests', () => {
    test('should find test file in same directory', async () => {
      fs.existsSync.mockImplementation((p) =>
        p.endsWith('user.test.js')
      );

      const tests = await verifier.findRelatedTests('/project/src/user.js');

      expect(tests).toContain('/project/src/user.test.js');
    });
  });

  describe('getSummary', () => {
    test('should return empty summary initially', () => {
      const summary = verifier.getSummary();

      expect(summary.filesVerified).toBe(0);
      expect(summary.filesWithErrors).toBe(0);
    });
  });
});
```

### Integra√ß√£o no Step5

**Arquivo:** `src/commands/task-executor/steps/step5/index.js`

```javascript
const { createVerifier } = require('../../../../shared/services/incremental-verifier');

// Criar verifier no in√≠cio do step
const verifier = createVerifier(state.folder, {
  runLint: true,
  runTypeCheck: true,
  runRelatedTests: true,
  stopOnFirstError: true
});

// Hook para quando Claude modifica um arquivo
const onFileModified = async (filePath) => {
  const result = await verifier.verifyFile(filePath);

  if (!result.success) {
    logger.error(`‚ùå Verification failed for ${filePath}`);

    // Injetar erro no pr√≥ximo prompt para Claude corrigir
    const errorContext = `
## VERIFICATION ERROR - FIX IMMEDIATELY

The following errors were detected in \`${path.relative(state.folder, filePath)}\`:

${result.errors.map(e => `- Line ${e.line || '?'}: ${e.message}`).join('\n')}

**Instructions:**
1. Fix these errors BEFORE continuing with other changes
2. The errors are in the file you just modified
3. After fixing, continue with the task
`;

    return { shouldPause: true, errorContext };
  }

  logger.success(`‚úÖ ${path.basename(filePath)} verified`);
  return { shouldPause: false };
};
```

### Ganhos Estimados
- **Bugs acumulados:** -70% (detecta na hora)
- **Tempo de debug:** -50% (sabe qual mudan√ßa quebrou)
- **Loops de corre√ß√£o:** -40% (erros menores e isolados)

---

## 12. Specification-First Development

### O Que √â
Sistema que gera uma especifica√ß√£o detalhada ANTES de implementar, permitindo valida√ß√£o do entendimento antes do c√≥digo.

### O Problema
- IA implementa direto sem confirmar entendimento
- Resultado pode n√£o ser o que o usu√°rio queria
- Retrabalho por mal-entendido
- Sem documenta√ß√£o do que foi especificado

### A Solu√ß√£o
Gerar SPEC.md primeiro, validar, depois implementar seguindo a spec.

### Como Implementar

**Novo arquivo:** `src/shared/services/spec-generator/index.js`

```javascript
const fs = require('fs');
const path = require('path');

// Template de especifica√ß√£o
const SPEC_TEMPLATE = `# Specification: {{TITLE}}

Generated: {{DATE}}
Task: {{TASK_DESCRIPTION}}

---

## 1. Overview

### What will be implemented
{{OVERVIEW}}

### Success Criteria
{{SUCCESS_CRITERIA}}

---

## 2. Functional Requirements

{{FUNCTIONAL_REQUIREMENTS}}

---

## 3. Technical Approach

### Architecture
{{ARCHITECTURE}}

### Files to Create/Modify
{{FILES_LIST}}

### Dependencies
{{DEPENDENCIES}}

---

## 4. API Contract (if applicable)

{{API_CONTRACT}}

---

## 5. Edge Cases & Error Handling

{{EDGE_CASES}}

---

## 6. Testing Strategy

{{TESTING_STRATEGY}}

---

## 7. Acceptance Checklist

{{ACCEPTANCE_CHECKLIST}}

---

## 8. Open Questions

{{OPEN_QUESTIONS}}

---

**Status:** PENDING_APPROVAL

To approve this specification, the user should confirm.
After approval, implementation will follow this spec exactly.
`;

class SpecGenerator {
  constructor(options = {}) {
    this.options = options;
  }

  // Gerar prompt para criar especifica√ß√£o
  buildSpecPrompt(taskDescription, codeContext = '') {
    return `
## TASK: Generate Specification Document

Before implementing anything, create a detailed specification document.

### Task Description
${taskDescription}

### Code Context
${codeContext || 'No specific context provided.'}

### Instructions

Generate a specification following this EXACT structure:

1. **Overview**: What will be built? (2-3 sentences)

2. **Success Criteria**: How do we know it's done? (bullet points)

3. **Functional Requirements**:
   - List each requirement with ID (FR-001, FR-002, etc.)
   - Be specific about behavior
   - Include input/output expectations

4. **Technical Approach**:
   - Architecture decisions
   - Files to create/modify (with paths)
   - External dependencies needed

5. **API Contract** (if applicable):
   - Endpoints with methods
   - Request/response schemas
   - Error responses

6. **Edge Cases**:
   - What happens with invalid input?
   - Error scenarios
   - Boundary conditions

7. **Testing Strategy**:
   - What tests are needed?
   - Test categories (unit, integration)
   - Key test cases

8. **Acceptance Checklist**:
   - [ ] Checkbox items for verification
   - [ ] Include tests passing
   - [ ] Include code review items

9. **Open Questions**:
   - Any ambiguities that need clarification?
   - Decisions that need user input?

### Output Format

Output ONLY the specification document in markdown format.
Do NOT include any implementation code.
Be thorough and specific.
`;
  }

  // Parse especifica√ß√£o gerada
  parseSpec(specContent) {
    const sections = {};

    // Extract title
    const titleMatch = specContent.match(/# Specification: (.+)/);
    sections.title = titleMatch ? titleMatch[1] : 'Untitled';

    // Extract functional requirements
    const frMatch = specContent.match(/## \d+\. Functional Requirements\s*([\s\S]*?)(?=## \d+\.|$)/);
    if (frMatch) {
      const requirements = frMatch[1].match(/FR-\d+[^FR]*/g) || [];
      sections.functionalRequirements = requirements.map(r => r.trim());
    }

    // Extract files list
    const filesMatch = specContent.match(/### Files to Create\/Modify\s*([\s\S]*?)(?=###|## \d+\.|$)/);
    if (filesMatch) {
      const files = filesMatch[1].match(/`([^`]+)`/g) || [];
      sections.files = files.map(f => f.replace(/`/g, ''));
    }

    // Extract acceptance checklist
    const checklistMatch = specContent.match(/## \d+\. Acceptance Checklist\s*([\s\S]*?)(?=## \d+\.|$)/);
    if (checklistMatch) {
      const items = checklistMatch[1].match(/- \[ \] .+/g) || [];
      sections.acceptanceChecklist = items.map(i => i.replace('- [ ] ', ''));
    }

    // Extract open questions
    const questionsMatch = specContent.match(/## \d+\. Open Questions\s*([\s\S]*?)(?=## \d+\.|---|$)/);
    if (questionsMatch) {
      const questions = questionsMatch[1].match(/- .+/g) || [];
      sections.openQuestions = questions.map(q => q.replace('- ', ''));
    }

    sections.raw = specContent;
    sections.hasOpenQuestions = (sections.openQuestions?.length || 0) > 0;

    return sections;
  }

  // Salvar especifica√ß√£o
  async saveSpec(taskFolder, specContent) {
    const specPath = path.join(taskFolder, 'SPEC.md');
    fs.writeFileSync(specPath, specContent);
    return specPath;
  }

  // Gerar prompt de implementa√ß√£o baseado na spec
  buildImplementationPrompt(specContent) {
    return `
## IMPLEMENTATION MODE

You have an APPROVED specification. Implement EXACTLY as specified.

### Specification
${specContent}

### Instructions

1. Follow the specification EXACTLY
2. Implement all Functional Requirements (FR-xxx)
3. Handle all Edge Cases listed
4. Create/modify only the files listed
5. Ensure all Acceptance Checklist items will pass

### Rules
- Do NOT deviate from the spec
- If something is unclear, implement the most reasonable interpretation
- Add code comments referencing requirement IDs (e.g., // FR-001)
- Write tests as specified in Testing Strategy

Begin implementation.
`;
  }

  // Verificar se spec foi aprovada
  isApproved(specPath) {
    if (!fs.existsSync(specPath)) return false;

    const content = fs.readFileSync(specPath, 'utf-8');
    return content.includes('**Status:** APPROVED');
  }

  // Aprovar spec
  approveSpec(specPath) {
    let content = fs.readFileSync(specPath, 'utf-8');
    content = content.replace('**Status:** PENDING_APPROVAL', '**Status:** APPROVED');
    content += `\n\nApproved at: ${new Date().toISOString()}\n`;
    fs.writeFileSync(specPath, content);
  }
}

const createSpecGenerator = (options) => new SpecGenerator(options);

module.exports = {
  SpecGenerator,
  createSpecGenerator,
  SPEC_TEMPLATE
};
```

### Integra√ß√£o no Fluxo

**Novo Step:** `src/commands/task-executor/steps/step4-spec/index.js`

```javascript
const { createSpecGenerator } = require('../../../../shared/services/spec-generator');
const readline = require('readline');

const executeStep4Spec = async (state, executeClaude) => {
  const specGenerator = createSpecGenerator();

  // 1. Gerar especifica√ß√£o
  logger.info('üìã Generating specification...');

  const specPrompt = specGenerator.buildSpecPrompt(
    state.taskDescription,
    state.codeContext
  );

  const specResult = await executeClaude(specPrompt, state.taskFolder);
  const specContent = specResult.output;

  // 2. Salvar e parsear
  const specPath = await specGenerator.saveSpec(state.taskFolder, specContent);
  const parsed = specGenerator.parseSpec(specContent);

  logger.info(`üìã Specification saved to ${specPath}`);

  // 3. Mostrar resumo
  console.log('\n' + '='.repeat(60));
  console.log('SPECIFICATION SUMMARY');
  console.log('='.repeat(60));
  console.log(`Title: ${parsed.title}`);
  console.log(`Requirements: ${parsed.functionalRequirements?.length || 0}`);
  console.log(`Files to modify: ${parsed.files?.join(', ') || 'None specified'}`);
  console.log(`Acceptance items: ${parsed.acceptanceChecklist?.length || 0}`);

  if (parsed.hasOpenQuestions) {
    console.log('\n‚ö†Ô∏è  OPEN QUESTIONS:');
    parsed.openQuestions.forEach(q => console.log(`   - ${q}`));
  }

  console.log('='.repeat(60) + '\n');

  // 4. Pedir aprova√ß√£o (se n√£o for auto-approve)
  if (!state.options.autoApprove) {
    const rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout
    });

    const answer = await new Promise(resolve => {
      rl.question('Approve specification? (y/n/edit): ', resolve);
    });
    rl.close();

    if (answer.toLowerCase() === 'n') {
      logger.warning('Specification rejected. Please modify and retry.');
      return { success: false, reason: 'rejected' };
    }

    if (answer.toLowerCase() === 'edit') {
      logger.info(`Edit the spec at: ${specPath}`);
      logger.info('Run again after editing.');
      return { success: false, reason: 'editing' };
    }
  }

  // 5. Aprovar
  specGenerator.approveSpec(specPath);
  logger.success('‚úÖ Specification approved!');

  return {
    success: true,
    specPath,
    implementationPrompt: specGenerator.buildImplementationPrompt(specContent)
  };
};

module.exports = { executeStep4Spec };
```

### Ganhos Estimados
- **Alinhamento com expectativa:** +60-80%
- **Retrabalho por mal-entendido:** -50%
- **Documenta√ß√£o:** +100% (spec vira documenta√ß√£o)
- **Clareza de requisitos:** +70%

---

## 13. Smart Auto-Rollback

### O Que √â
Sistema de checkpoints autom√°ticos com rollback inteligente quando algo d√° muito errado.

### O Problema
- Quando IA quebra muita coisa, precisa desfazer manualmente
- git reset --hard pode perder trabalho bom
- Sem visibilidade de "pontos seguros" para voltar
- Medo de experimentar por n√£o poder voltar atr√°s

### A Solu√ß√£o
Checkpoints autom√°ticos em pontos seguros com rollback inteligente.

### Como Implementar

**Novo arquivo:** `src/shared/services/smart-rollback/index.js`

```javascript
const { execSync, spawn } = require('child_process');
const path = require('path');
const fs = require('fs');

class SmartRollback {
  constructor(projectPath, options = {}) {
    this.projectPath = projectPath;
    this.options = {
      maxCheckpoints: options.maxCheckpoints || 10,
      checkpointPrefix: options.checkpointPrefix || 'claudiomiro-checkpoint',
      ...options
    };
    this.checkpoints = [];
  }

  // Criar checkpoint
  async createCheckpoint(description) {
    const timestamp = Date.now();
    const checkpointId = `${this.options.checkpointPrefix}-${timestamp}`;

    try {
      // Verificar se h√° mudan√ßas
      const status = this.exec('git status --porcelain');

      if (!status.trim()) {
        console.log('‚ÑπÔ∏è  No changes to checkpoint');
        return null;
      }

      // Stage todas as mudan√ßas
      this.exec('git add -A');

      // Criar commit tempor√°rio
      this.exec(`git commit -m "CHECKPOINT: ${description}" --no-verify`);

      // Criar tag para f√°cil refer√™ncia
      this.exec(`git tag ${checkpointId}`);

      const checkpoint = {
        id: checkpointId,
        description,
        timestamp,
        commit: this.exec('git rev-parse HEAD').trim(),
        files: status.split('\n').filter(Boolean).length
      };

      this.checkpoints.push(checkpoint);

      // Limpar checkpoints antigos
      await this.cleanupOldCheckpoints();

      console.log(`üìå Checkpoint created: ${checkpointId}`);

      return checkpoint;
    } catch (error) {
      console.error('Failed to create checkpoint:', error.message);
      return null;
    }
  }

  // Rollback para checkpoint
  async rollbackTo(checkpointId) {
    const checkpoint = this.checkpoints.find(c => c.id === checkpointId);

    if (!checkpoint) {
      throw new Error(`Checkpoint not found: ${checkpointId}`);
    }

    console.log(`üîÑ Rolling back to: ${checkpoint.description}`);

    try {
      // Reset para o commit do checkpoint
      this.exec(`git reset --hard ${checkpoint.commit}`);

      // Remover checkpoints posteriores
      const checkpointIndex = this.checkpoints.findIndex(c => c.id === checkpointId);
      const removed = this.checkpoints.splice(checkpointIndex + 1);

      // Limpar tags dos checkpoints removidos
      for (const cp of removed) {
        try {
          this.exec(`git tag -d ${cp.id}`);
        } catch {}
      }

      console.log(`‚úÖ Rolled back successfully. Removed ${removed.length} later checkpoints.`);

      return { success: true, checkpoint };
    } catch (error) {
      console.error('Rollback failed:', error.message);
      return { success: false, error: error.message };
    }
  }

  // Rollback para √∫ltimo checkpoint
  async rollbackToLast() {
    if (this.checkpoints.length === 0) {
      console.log('‚ö†Ô∏è  No checkpoints available');
      return { success: false, reason: 'no checkpoints' };
    }

    const lastCheckpoint = this.checkpoints[this.checkpoints.length - 1];

    // Descartar mudan√ßas ap√≥s √∫ltimo checkpoint
    this.exec('git reset --hard HEAD');

    console.log(`‚úÖ Rolled back to last checkpoint: ${lastCheckpoint.description}`);

    return { success: true, checkpoint: lastCheckpoint };
  }

  // Detectar se deve fazer rollback autom√°tico
  async shouldAutoRollback(verificationResult) {
    if (!verificationResult) return false;

    const { errors = [], testResults = {} } = verificationResult;

    // Crit√©rios para rollback autom√°tico
    const catastrophicConditions = [
      // Muitos erros de sintaxe
      errors.filter(e => e.type === 'syntax').length > 5,

      // Mais de 50% dos testes falhando
      testResults.failed > testResults.total * 0.5,

      // Build completamente quebrado
      errors.some(e => e.message?.includes('Cannot find module') && e.critical),

      // Erros em arquivos core
      errors.some(e => e.file?.includes('index.js') || e.file?.includes('main.js'))
    ];

    return catastrophicConditions.some(Boolean);
  }

  // Auto-rollback se catastr√≥fico
  async autoRollbackIfNeeded(verificationResult) {
    if (await this.shouldAutoRollback(verificationResult)) {
      console.log('üö® Catastrophic failure detected! Auto-rolling back...');
      return await this.rollbackToLast();
    }

    return { success: true, rolledBack: false };
  }

  // Limpar checkpoints antigos
  async cleanupOldCheckpoints() {
    while (this.checkpoints.length > this.options.maxCheckpoints) {
      const old = this.checkpoints.shift();
      try {
        this.exec(`git tag -d ${old.id}`);
      } catch {}
    }
  }

  // Listar checkpoints
  listCheckpoints() {
    return this.checkpoints.map(c => ({
      id: c.id,
      description: c.description,
      timestamp: new Date(c.timestamp).toISOString(),
      filesChanged: c.files
    }));
  }

  // Squash checkpoints em um commit limpo
  async squashCheckpoints(finalMessage) {
    if (this.checkpoints.length === 0) {
      return { success: false, reason: 'no checkpoints' };
    }

    const firstCheckpoint = this.checkpoints[0];

    try {
      // Soft reset para antes do primeiro checkpoint
      this.exec(`git reset --soft ${firstCheckpoint.commit}~1`);

      // Commit com mensagem final
      this.exec(`git commit -m "${finalMessage}"`);

      // Limpar todas as tags de checkpoint
      for (const cp of this.checkpoints) {
        try {
          this.exec(`git tag -d ${cp.id}`);
        } catch {}
      }

      this.checkpoints = [];

      console.log('‚úÖ Checkpoints squashed into single commit');

      return { success: true };
    } catch (error) {
      console.error('Squash failed:', error.message);
      return { success: false, error: error.message };
    }
  }

  // Helper para executar comandos
  exec(command) {
    return execSync(command, {
      cwd: this.projectPath,
      encoding: 'utf-8',
      stdio: ['pipe', 'pipe', 'pipe']
    });
  }
}

const createRollbackManager = (projectPath, options) => {
  return new SmartRollback(projectPath, options);
};

module.exports = {
  SmartRollback,
  createRollbackManager
};
```

**Novo arquivo:** `src/shared/services/smart-rollback/index.test.js`

```javascript
const { SmartRollback } = require('./index');
const { execSync } = require('child_process');

jest.mock('child_process');

describe('SmartRollback', () => {
  let rollback;

  beforeEach(() => {
    rollback = new SmartRollback('/project');
    execSync.mockReturnValue('');
  });

  describe('shouldAutoRollback', () => {
    test('should return true for many syntax errors', async () => {
      const result = {
        errors: [
          { type: 'syntax' },
          { type: 'syntax' },
          { type: 'syntax' },
          { type: 'syntax' },
          { type: 'syntax' },
          { type: 'syntax' }
        ]
      };

      const should = await rollback.shouldAutoRollback(result);
      expect(should).toBe(true);
    });

    test('should return true when >50% tests fail', async () => {
      const result = {
        testResults: { total: 10, failed: 6 }
      };

      const should = await rollback.shouldAutoRollback(result);
      expect(should).toBe(true);
    });

    test('should return false for minor issues', async () => {
      const result = {
        errors: [{ type: 'warning' }],
        testResults: { total: 10, failed: 1 }
      };

      const should = await rollback.shouldAutoRollback(result);
      expect(should).toBe(false);
    });
  });

  describe('listCheckpoints', () => {
    test('should return empty list initially', () => {
      expect(rollback.listCheckpoints()).toEqual([]);
    });
  });
});
```

### Integra√ß√£o no Step5

**Arquivo:** `src/commands/task-executor/steps/step5/index.js`

```javascript
const { createRollbackManager } = require('../../../../shared/services/smart-rollback');

const executeStep5 = async (state, executeClaude) => {
  const rollback = createRollbackManager(state.folder);

  // Checkpoint antes de come√ßar
  await rollback.createCheckpoint('Before implementation start');

  let lastSuccessfulStep = null;

  try {
    // Executar implementa√ß√£o
    for (const subtask of state.subtasks) {
      const result = await executeClaude(subtask.prompt, state.taskFolder);

      // Verificar resultado
      const verification = await verifier.verifyAll();

      // Auto-rollback se catastr√≥fico
      const rollbackResult = await rollback.autoRollbackIfNeeded(verification);

      if (rollbackResult.rolledBack) {
        logger.warning(`Rolled back due to catastrophic failure. Retrying with different approach...`);
        // Retry com prompt modificado
        continue;
      }

      if (verification.success) {
        // Checkpoint ap√≥s sucesso
        await rollback.createCheckpoint(`Completed: ${subtask.name}`);
        lastSuccessfulStep = subtask;
      }
    }

    // Squash checkpoints no final
    await rollback.squashCheckpoints(state.commitMessage);

  } catch (error) {
    logger.error(`Implementation failed: ${error.message}`);

    // Oferecer rollback
    if (lastSuccessfulStep) {
      logger.info(`Last successful checkpoint: ${lastSuccessfulStep.name}`);
      // Rollback autom√°tico ou perguntar usu√°rio
    }

    throw error;
  }
};
```

### Comandos CLI

```bash
# Listar checkpoints
claudiomiro --list-checkpoints

# Rollback manual
claudiomiro --rollback=claudiomiro-checkpoint-1234567890

# Rollback para √∫ltimo checkpoint
claudiomiro --rollback=last
```

### Ganhos Estimados
- **Tempo de recupera√ß√£o:** -80% (rollback instant√¢neo)
- **Seguran√ßa:** +50% (sempre pode voltar)
- **Confian√ßa para experimentar:** +60%
- **Stress do desenvolvedor:** -40%

---

## Estimativa de Ganhos Totais

### Metodologia
Os ganhos foram estimados baseando-se em:
1. An√°lise comparativa CodeMachine vs Claudiomiro
2. Benchmarks de sistemas similares na literatura
3. Experi√™ncia pr√°tica com automa√ß√£o de c√≥digo

### Ganhos por Categoria

#### Assertividade (Qualidade do C√≥digo Gerado)

| Melhoria | Ganho Estimado | Justificativa |
|----------|----------------|---------------|
| Three-Phase Generation | +25-35% | Planejamento baseado em padr√µes reais |
| Cross-Task Learning | +20-30% | Reutiliza abordagens comprovadas |
| Context-Aware Instructions | +15-20% | Segue regras do stack |
| Symbol-Linked Briefings | +25-35% | C√≥digo de refer√™ncia inclu√≠do |
| **TOTAL ASSERTIVIDADE** | **+40-55%** | Composto (n√£o aditivo) |

#### Velocidade (Tempo de Execu√ß√£o)

| Melhoria | Ganho Estimado | Justificativa |
|----------|----------------|---------------|
| Learning Fallbacks | +30-40% | N√£o reinicia do zero |
| Cross-Task Learning | +15-20% | N√£o reinventa solu√ß√µes |
| Predictive Behaviors | +10-15% | Evita loops desnecess√°rios |
| Semantic Anchors | +5-10% | Carrega s√≥ o necess√°rio |
| **TOTAL VELOCIDADE** | **+25-35%** | Composto |

#### Taxa de Sucesso (Tarefas Completadas sem Interven√ß√£o)

| Melhoria | Ganho Estimado | Justificativa |
|----------|----------------|---------------|
| Learning Fallbacks | +35-45% | Recupera√ß√£o inteligente |
| Three-Phase Generation | +15-25% | Menos erros de planejamento |
| Confidence Checkpoints | +10-15% | Captura problemas antes |
| **TOTAL SUCESSO** | **+30-45%** | Composto |

#### Experi√™ncia do Usu√°rio (UX)

| Melhoria | Ganho Estimado | Justificativa |
|----------|----------------|---------------|
| Confidence Checkpoints | +25-30% | Transpar√™ncia |
| Predictive Behaviors | +20-25% | Usu√°rio informado |
| Cross-Task Learning | +15-20% | Consist√™ncia vis√≠vel |
| **TOTAL UX** | **+30-40%** | Composto |

### Resumo Final

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    GANHOS ESTIMADOS                         ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Assertividade (qualidade do c√≥digo)     ‚îÇ  +40-55%        ‚îÇ
‚îÇ  Velocidade (tempo de execu√ß√£o)          ‚îÇ  +25-35%        ‚îÇ
‚îÇ  Taxa de Sucesso (sem interven√ß√£o)       ‚îÇ  +30-45%        ‚îÇ
‚îÇ  Experi√™ncia do Usu√°rio                  ‚îÇ  +30-40%        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  GANHO M√âDIO GERAL                       ‚îÇ  +35-45%        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Observa√ß√µes

1. **Ganhos s√£o compostos, n√£o aditivos**: M√∫ltiplas melhorias t√™m efeito sin√©rgico
2. **Depend√™ncia do Code Index**: 4 das 8 melhorias dependem do Code Index funcionar
3. **Depend√™ncia do Local LLM**: 3 melhorias s√£o potencializadas pelo Local LLM
4. **Curva de aprendizado**: Learning Fallbacks e Cross-Task Learning melhoram com o tempo
5. **Impacto inicial menor**: Primeiras execu√ß√µes n√£o ter√£o hist√≥rico para aprender

### Ordem de Implementa√ß√£o Recomendada

1. **Three-Phase Generation** (1-2h) - Alto impacto, baixo esfor√ßo
2. **Context-Aware Instructions** (2-3h) - F√°cil, benef√≠cio imediato
3. **Confidence Checkpoints** (2-3h) - Baixo risco, boa UX
4. **Learning Fallbacks** (4-6h) - Alto impacto ap√≥s acumular dados
5. **Cross-Task Learning** (4-6h) - Melhora com uso
6. **Predictive Behaviors** (3-4h) - Depende de hist√≥rico
7. **Semantic Anchors** (6-8h) - Complexo, depende de Code Index
8. **Symbol-Linked Briefings** (6-8h) - Complexo, maior benef√≠cio

**Tempo total estimado: 28-40 horas de desenvolvimento**

---

*Documento gerado em 2025-11-29*
